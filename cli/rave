#!/usr/bin/env python3
"""
RAVE CLI - Reproducible AI Virtual Environment Management
Comprehensive CLI for managing company development environments, users, and OAuth integration.
"""

import os
import sys
import json
import shlex
import shutil
import subprocess
import tempfile
import textwrap
import builtins
import click
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Add the cli directory to Python path for imports
CLI_DIR = Path(__file__).parent
sys.path.insert(0, str(CLI_DIR))

from vm_manager import VMManager
from user_manager import UserManager
from oauth_manager import OAuthManager
from platform_utils import PlatformManager

# Constants for secrets management
DEFAULT_AGE_KEY_PATH = Path.home() / ".config" / "sops" / "age" / "keys.txt"
DEFAULT_SECRETS_FILE = Path("config/secrets.yaml")

PROVIDER_META = {
    "google": {
        "slug": "google_oauth2",
        "label": "Google",
        "scopes": ["openid", "email", "profile"],
        "args": {
            "access_type": "offline",
            "prompt": "select_account consent",
            "scope": "email,profile",
        },
    },
    "github": {
        "slug": "github",
        "label": "GitHub",
        "scopes": ["read:user", "user:email"],
        "args": {
            "scope": "user:email",
        },
    },
}

SLUG_TO_PROVIDER = {meta["slug"]: key for key, meta in PROVIDER_META.items()}

PROVIDER_ALIASES = {
    "google": PROVIDER_META["google"]["slug"],
    "google_oauth2": PROVIDER_META["google"]["slug"],
    "github": PROVIDER_META["github"]["slug"],
}

DEFAULT_PROVIDER_SLUG = PROVIDER_META["google"]["slug"]

PROVIDER_ENV_VARS: Dict[str, Tuple[str, str]] = {
    "google": ("GOOGLE_OAUTH_CLIENT_ID", "GOOGLE_OAUTH_CLIENT_SECRET"),
    "google_oauth2": ("GOOGLE_OAUTH_CLIENT_ID", "GOOGLE_OAUTH_CLIENT_SECRET"),
    "github": ("GITHUB_OAUTH_CLIENT_ID", "GITHUB_OAUTH_CLIENT_SECRET"),
}

_ENV_LOADED = False
_ENV_SOURCES: List[str] = []


def _clean_env_value(raw_value: str) -> str:
    value = raw_value.strip()
    if not value:
        return ""

    if len(value) >= 2 and value[0] == value[-1] and value[0] in {"'", '"'}:
        return value[1:-1]

    for marker in (" #", "\t#"):
        marker_index = value.find(marker)
        if marker_index != -1:
            value = value[:marker_index].rstrip()
            break

    return value.replace("\\n", "\n")


def _parse_env_line(line: str) -> Optional[Tuple[str, str]]:
    stripped = line.strip()
    if not stripped or stripped.startswith("#"):
        return None

    if stripped.startswith("export "):
        stripped = stripped[len("export "):].lstrip()

    if "=" not in stripped:
        return None

    key, value = stripped.split("=", 1)
    key = key.strip()
    if not key:
        return None

    return key, _clean_env_value(value)


def _apply_env_file(path: Path) -> int:
    try:
        lines = path.read_text().splitlines()
    except (OSError, UnicodeDecodeError):
        return 0

    loaded = 0
    for raw_line in lines:
        entry = _parse_env_line(raw_line)
        if not entry:
            continue
        key, value = entry
        if key in os.environ:
            continue
        os.environ[key] = value
        loaded += 1
    return loaded


def _load_env_files() -> List[str]:
    global _ENV_LOADED, _ENV_SOURCES
    if _ENV_LOADED:
        return list(_ENV_SOURCES)

    candidates = [
        Path.cwd() / ".env",
        CLI_DIR.parent / ".env",
        Path.home() / ".config" / "rave" / ".env",
    ]

    seen: set = set()
    loaded_sources: List[str] = []

    for candidate in candidates:
        try:
            resolved = candidate.resolve()
        except FileNotFoundError:
            resolved = candidate

        if resolved in seen or not resolved.exists():
            continue

        if _apply_env_file(resolved):
            loaded_sources.append(str(resolved))

        seen.add(resolved)

    _ENV_LOADED = True
    _ENV_SOURCES = loaded_sources
    return list(_ENV_SOURCES)

_INIT_ENV_SOURCES = _load_env_files()


def _normalize_provider_choice(value: Optional[str], default: str) -> str:
    if value is None:
        return default
    key = value.strip().lower()
    if not key:
        return default
    if key in PROVIDER_ALIASES:
        return PROVIDER_ALIASES[key]
    raise click.BadParameter("Unsupported provider. Choose from: google, github")


def _get_default_provider(ctx) -> str:
    config = ctx.obj.get('config', {})
    raw = config.get('oauth_provider')
    if raw:
        return _normalize_provider_choice(raw, DEFAULT_PROVIDER_SLUG)
    return DEFAULT_PROVIDER_SLUG
PLACEHOLDER_KEY = "age1exampleexampleexampleexampleexampleexampleexampleexample"


def _parse_metadata(pairs: List[str]) -> Dict[str, str]:
    """Convert CLI --meta key=value entries into a dict."""

    metadata: Dict[str, str] = {}
    for pair in pairs:
        if "=" not in pair:
            raise click.BadParameter(
                f"Metadata entry '{pair}' must be in key=value format"
            )
        key, value = pair.split("=", 1)
        key = key.strip()
        value = value.strip()
        if not key or not value:
            raise click.BadParameter(
                f"Metadata entry '{pair}' must include non-empty key and value"
            )
        metadata[key] = value
    return metadata


def _parse_metadata_option(value: Optional[str]) -> Dict[str, str]:
    """Parse metadata supplied via CLI option.

    Accepts either a JSON object string or comma-separated key=value pairs.
    """

    if not value:
        return {}

    text = value.strip()
    if not text:
        return {}

    if text.startswith("{"):
        try:
            parsed = json.loads(text)
        except json.JSONDecodeError as exc:
            raise click.BadParameter(
                f"Invalid metadata JSON: {exc.msg}"
            )
        if not isinstance(parsed, dict):
            raise click.BadParameter("Metadata JSON must decode to an object")
        return {str(k): str(v) for k, v in parsed.items() if str(v).strip()}

    entries = [segment.strip() for segment in text.split(",") if segment.strip()]
    if not entries:
        return {}
    return _parse_metadata(entries)


def _provider_meta_from_slug(slug: str) -> Dict[str, any]:
    provider_key = SLUG_TO_PROVIDER.get(slug)
    if not provider_key:
        raise click.ClickException(f"Unknown provider slug '{slug}'")
    return PROVIDER_META[provider_key]


def _provider_meta_from_input(value: Optional[str], default_slug: str) -> Dict[str, any]:
    slug = _normalize_provider_choice(value, default_slug)
    return _provider_meta_from_slug(slug)


def _provider_label_from_slug(slug: str) -> str:
    return _provider_meta_from_slug(slug)["label"]


def _list_company_names() -> List[str]:
    ensure_config_dir()
    return sorted(path.stem for path in VMS_DIR.glob("*.json"))


def _load_company_config_or_exit(vm_manager: VMManager, company_name: str) -> Dict:
    config = vm_manager._load_vm_config(company_name)
    if not config:
        raise click.ClickException(f"VM '{company_name}' not found. Run 'rave vm list' to confirm the name.")
    return config


def _normalize_host_entry(entry: str, https_port: int) -> Optional[str]:
    raw = entry.strip()
    if not raw:
        return None
    if raw.startswith("http://") or raw.startswith("https://"):
        return raw.rstrip("/")
    host = raw
    port = https_port
    if ":" in raw:
        host_part, port_part = raw.split(":", 1)
        host = host_part or "localhost"
        port = port_part or https_port
        return f"https://{host}:{port}".rstrip("/")
    return f"https://{host}:{https_port}"


def _build_redirect_hosts_and_uris(
    slug: str,
    https_port: int,
    extra_hosts: List[str],
    *,
    include_loopback: bool = True,
) -> tuple[List[str], List[str]]:
    hosts: List[str] = []
    if include_loopback:
        hosts.extend([
            f"https://localhost:{https_port}",
            f"https://127.0.0.1:{https_port}",
        ])
    for host in extra_hosts:
        normalized = _normalize_host_entry(host, https_port)
        if normalized:
            hosts.append(normalized)
    uris: List[str] = []
    for host in hosts:
        base = host.rstrip("/")
        uri = f"{base}/gitlab/users/auth/{slug}/callback"
        if uri not in uris:
            uris.append(uri)
    unique_hosts: List[str] = []
    for host in hosts:
        if host not in unique_hosts:
            unique_hosts.append(host)
    return unique_hosts, uris


def _render_gcloud_command(
    project: Optional[str],
    client_name: str,
    display_name: str,
    redirect_uris: List[str],
    scopes: List[str],
) -> str:
    scopes_value = ",".join(scopes)
    header = ["gcloud"]
    if project:
        header.extend(["--project", project])
    header.extend(["alpha", "iam", "oauth-clients", "create", client_name])

    lines = [" ".join(shlex.quote(part) for part in header) + " \\"]
    lines.append("  --location=global \\")
    lines.append("  --client-type=confidential-client \\")
    lines.append(f"  --display-name={shlex.quote(display_name)} \\")
    lines.append("  --allowed-grant-types=authorization-code-grant,refresh-token-grant \\")
    if scopes:
        lines.append(f"  --allowed-scopes={shlex.quote(scopes_value)} \\")
    for index, uri in enumerate(redirect_uris):
        suffix = " \\" if index < len(redirect_uris) - 1 else ""
        lines.append(f"  --allowed-redirect-uris={shlex.quote(uri)}{suffix}")
    return "\n".join(lines)


# Global configuration
CONFIG_DIR = Path.home() / ".config" / "rave"
CONFIG_FILE = CONFIG_DIR / "config.json"
VMS_DIR = CONFIG_DIR / "vms"

def ensure_config_dir():
    """Ensure configuration directory exists."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    VMS_DIR.mkdir(parents=True, exist_ok=True)

def load_config() -> Dict:
    """Load RAVE configuration."""
    if not CONFIG_FILE.exists():
        return {}
    try:
        return json.loads(CONFIG_FILE.read_text())
    except (json.JSONDecodeError, FileNotFoundError):
        return {}

def save_config(config: Dict):
    """Save RAVE configuration."""
    ensure_config_dir()
    CONFIG_FILE.write_text(json.dumps(config, indent=2))

@click.group()
@click.version_option(version="1.0.0")
@click.pass_context
def cli(ctx):
    """RAVE - Reproducible AI Virtual Environment Management
    
    Manage company development environments, users, and OAuth integration.
    """
    ensure_config_dir()
    ctx.ensure_object(dict)
    ctx.obj['config'] = load_config()
    ctx.obj['vm_manager'] = VMManager(VMS_DIR)
    ctx.obj['user_manager'] = UserManager()
    ctx.obj['oauth_manager'] = OAuthManager()
    ctx.obj['platform'] = PlatformManager()

    default_provider = _get_default_provider(ctx)
    ctx.obj['user_manager'].set_default_provider(default_provider)

# Secrets management commands
@cli.group()
@click.pass_context
def secrets(ctx):
    """Secrets management helpers."""
    ctx.ensure_object(dict)


@cli.group()
@click.pass_context
def tls(ctx):
    """Trusted TLS helpers."""
    ctx.ensure_object(dict)


@cli.command('set-oauth-provider')
@click.argument('provider', type=click.Choice(['google', 'github'], case_sensitive=False))
@click.pass_context
def set_oauth_provider(ctx, provider: str):
    """Persist the default OAuth provider used for GitLab user management."""
    normalized = _normalize_provider_choice(provider, PROVIDER_ALIASES['google'])

    config = ctx.obj.get('config', {})
    config['oauth_provider'] = normalized
    save_config(config)

    ctx.obj['config'] = config

    ctx.obj['user_manager'].set_default_provider(normalized)
    click.echo(f"üîê Default OAuth provider set to {provider.capitalize()} ({normalized}).")


@tls.command()
@click.pass_context
def bootstrap(ctx):
    """Install mkcert and trust the local development CA on the host."""
    platform: PlatformManager = ctx.obj['platform']

    click.echo("üîê Preparing mkcert on the host‚Ä¶")
    result = platform.ensure_mkcert_installed()
    if not result.get("success"):
        click.echo(f"‚ùå {result.get('error', 'Failed to install mkcert')}")
        hint = result.get("hint")
        if hint:
            click.echo(f"   ‚Üí {hint}")
        sys.exit(1)

    if result.get("installed"):
        click.echo("‚úÖ mkcert installed successfully")
    else:
        click.echo("‚ÑπÔ∏è  mkcert already present")

    try:
        subprocess.run(["mkcert", "-install"], check=True)
    except subprocess.CalledProcessError as exc:
        click.echo("‚ùå mkcert failed to install the local CA")
        if exc.stderr:
            click.echo(f"   ‚Üí {exc.stderr.strip()}")
        sys.exit(1)

    caroot = platform.mkcert_caroot()
    if caroot:
        click.echo(f"üìÅ mkcert CA root: {caroot}")
    click.echo("‚úÖ Host trust store updated (you may need to restart browsers).")


@tls.command()
@click.argument('company_name')
@click.option(
    '--domain', 'domains', multiple=True,
    help='Hostname to include in the certificate (repeat for multiple).'
)
@click.pass_context
def issue(ctx, company_name: str, domains: List[str]):
    """Mint a trusted TLS certificate for a VM and install it."""

    vm_manager: VMManager = ctx.obj['vm_manager']
    platform: PlatformManager = ctx.obj['platform']

    default_domains = ["localhost", "127.0.0.1", "::1", "chat.localtest.me"]
    if not domains:
        domains = default_domains
    else:
        domains = [d.strip() for d in domains if d.strip()]
        if not domains:
            click.echo("‚ùå No valid domain names provided")
            sys.exit(1)

    if shutil.which("mkcert") is None:
        click.echo("‚ùå mkcert is not installed. Run 'rave tls bootstrap' first.")
        sys.exit(1)

    click.echo(f"üîè Issuing certificate for: {', '.join(domains)}")

    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        cert_path = tmp_path / "cert.pem"
        key_path = tmp_path / "key.pem"
        mkcert_cmd = [
            "mkcert",
            "-cert-file", str(cert_path),
            "-key-file", str(key_path),
            *domains,
        ]

        try:
            subprocess.run(mkcert_cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as exc:
            stderr = exc.stderr.decode() if isinstance(exc.stderr, bytes) else exc.stderr
            click.echo("‚ùå mkcert failed to issue the certificate")
            if stderr:
                click.echo(f"   ‚Üí {stderr.strip()}")
            sys.exit(1)

        caroot = platform.mkcert_caroot()
        if not caroot:
            click.echo("‚ùå Unable to locate mkcert CA root. Run 'rave tls bootstrap' again.")
            sys.exit(1)

        ca_path = caroot / "rootCA.pem"
        if not ca_path.exists():
            click.echo(f"‚ùå mkcert CA file not found at {ca_path}")
            sys.exit(1)

        cert_pem = cert_path.read_text()
        key_pem = key_path.read_text()
        ca_pem = ca_path.read_text()
        fullchain_pem = cert_pem + ca_pem

    result = vm_manager.install_tls_certificate(
        company_name,
        cert_pem=cert_pem,
        fullchain_pem=fullchain_pem,
        key_pem=key_pem,
        ca_pem=ca_pem,
    )

    if not result.get("success"):
        click.echo(f"‚ùå Failed to install certificate: {result.get('error')}")
        sys.exit(1)

    vm_manager.record_tls_metadata(company_name, {
        "domains": domains,
    })

    click.echo("‚úÖ Installed certificate under /var/lib/acme/localhost on the VM")
    click.echo("üîÅ nginx restarted to pick up the new TLS material")
    root_info = platform.mkcert_caroot()
    if root_info:
        click.echo(f"‚ÑπÔ∏è  If other devices need trust, share {root_info / 'rootCA.pem'}")


def _ensure_binary(name: str, install_hint: str) -> bool:
    """Check if a binary is available; emit guidance if missing."""
    if shutil.which(name):
        return True
    click.echo(f"‚ùå Missing dependency: {name}")
    click.echo(f"   ‚Üí {install_hint}")
    return False


def _extract_public_key(key_path: Path) -> Optional[str]:
    """Return the Age public key for a private key file."""
    try:
        output = subprocess.check_output(
            ["age-keygen", "-y", str(key_path)],
            text=True
        ).strip()
    except subprocess.CalledProcessError as exc:
        click.echo("‚ùå Failed to derive Age public key")
        click.echo(f"   {exc}")
        return None

    if "Public key:" in output:
        return output.split(":", 1)[1].strip()
    return output


def _update_sops_yaml(public_key: str, sops_path: Path) -> bool:
    """Ensure the Age key is referenced inside .sops.yaml."""
    if not sops_path.exists():
        click.echo(f"‚ùå {sops_path} not found; please create it before proceeding.")
        return False

    content = sops_path.read_text()
    if public_key in content:
        return True

    lines = content.splitlines()
    updated = False

    for idx, line in enumerate(lines):
        if PLACEHOLDER_KEY in line:
            cleaned = line.lstrip("#").strip()
            prefix = line[: len(line) - len(line.lstrip())]
            replacement = cleaned.replace(PLACEHOLDER_KEY, public_key, 1)
            lines[idx] = prefix + replacement
            updated = True
            break

    if not updated:
        # Try to insert after the keys: stanza
        for idx, line in enumerate(lines):
            if line.strip().startswith("keys:"):
                insertion = f"  - &team_key_cli {public_key}  # Added by 'rave secrets init'"
                lines.insert(idx + 1, insertion)
                updated = True
                break

    if not updated:
        click.echo("‚ö†Ô∏è Unable to automatically modify .sops.yaml. Please add the key manually:")
        click.echo(f"   Age public key: {public_key}")
        return False

    sops_path.write_text("\n".join(lines) + "\n")
    click.echo(f"‚úÖ Added Age public key to {sops_path}")
    return True


@secrets.command()
@click.option(
    "--key-file",
    default=str(DEFAULT_AGE_KEY_PATH),
    show_default=True,
    help="Location for the Age private key"
)
@click.option(
    "--secrets-file",
    default=str(DEFAULT_SECRETS_FILE),
    show_default=True,
    help="Path to the encrypted secrets file"
)
def init(key_file: str, secrets_file: str):
    """Guide through SOPS + Age bootstrap."""

    click.echo("üîê RAVE secrets bootstrap")

    sops_ok = _ensure_binary(
        "sops",
        "Install from https://github.com/getsops/sops/releases"
    )
    age_ok = _ensure_binary(
        "age-keygen",
        "Install age (https://github.com/FiloSottile/age/releases) so age-keygen is available"
    )

    if not (sops_ok and age_ok):
        sys.exit(1)

    key_path = Path(key_file).expanduser()
    key_path.parent.mkdir(parents=True, exist_ok=True)

    if not key_path.exists():
        click.echo(f"üóùÔ∏è  Generating Age key at {key_path}")
        try:
            subprocess.run([
                "age-keygen",
                "-o",
                str(key_path)
            ], check=True)
        except subprocess.CalledProcessError as exc:
            click.echo("‚ùå Failed to generate Age key")
            click.echo(f"   {exc}")
            sys.exit(1)
        key_path.chmod(0o600)
    else:
        click.echo(f"‚ÑπÔ∏è  Reusing existing Age key at {key_path}")

    public_key = _extract_public_key(key_path)
    if not public_key:
        sys.exit(1)

    sops_path = Path(".sops.yaml")
    _update_sops_yaml(public_key, sops_path)

    click.echo("üìå Export this before running Nix builds:")
    click.echo(f"   export SOPS_AGE_KEY_FILE={key_path}")

    secrets_path = Path(secrets_file)
    if not secrets_path.exists():
        click.echo(f"‚ùå {secrets_path} does not exist yet. Create it before editing with sops.")
    else:
        if click.confirm("Open secrets file with sops now?", default=True):
            env = os.environ.copy()
            env["SOPS_AGE_KEY_FILE"] = str(key_path)
            try:
                subprocess.run([
                    "sops",
                    str(secrets_path)
                ], check=True, env=env)
            except subprocess.CalledProcessError as exc:
                click.echo("‚ùå sops exited with an error")
                click.echo(f"   {exc}")

    guidance = textwrap.dedent(
        f"""
        Next steps:
          ‚Ä¢ After a VM boots, run 'rave secrets install <company>' (or otherwise place {key_path} at /var/lib/sops-nix/key.txt) so sops-nix can decrypt secrets.
          ‚Ä¢ Keep the Age private key backed up securely; losing it means secrets cannot be decrypted.
          ‚Ä¢ Re-run this command if you rotate keys or onboard new operators.
        """
    ).strip()
    click.echo(guidance)


def _load_decrypted_secrets(secrets_path: Path, age_key_path: Path) -> Optional[Dict]:
    env = os.environ.copy()
    env.setdefault("SOPS_AGE_KEY_FILE", str(age_key_path))

    try:
        output = subprocess.check_output(
            [
                "sops",
                "-d",
                "--output-type",
                "json",
                str(secrets_path),
            ],
            text=True,
            env=env,
        )
        return json.loads(output)
    except subprocess.CalledProcessError as exc:
        click.echo("‚ö†Ô∏è Unable to decrypt secrets file")
        click.echo(f"   {exc}")
    except (FileNotFoundError, json.JSONDecodeError) as exc:
        click.echo("‚ö†Ô∏è Failed to load secrets metadata")
        click.echo(f"   {exc}")
    return None


def _sync_vm_secrets(
    vm_manager: VMManager,
    company_name: str,
    key_file: Path,
    secrets_file: Path,
    *,
    restart_db: bool,
) -> Dict[str, any]:
    """Install the Age key and push decrypted secrets into the VM."""

    key_path = Path(key_file).expanduser()
    secrets_path = Path(secrets_file)

    if not key_path.exists():
        return {
            "success": False,
            "error": f"Age key not found at {key_path}"
        }

    age_result = vm_manager.install_age_key(company_name, key_path)
    if not age_result.get("success"):
        return {
            "success": False,
            "error": age_result.get("error", "Failed to install Age key")
        }

    age_remote_path = age_result.get("path", "/var/lib/sops-nix/key.txt")
    messages: List[str] = []
    warnings: List[str] = []
    installed_secrets: List[str] = []

    secrets_data: Optional[Dict] = None
    if secrets_path.exists():
        secrets_data = _load_decrypted_secrets(secrets_path, key_path)
        if secrets_data is None:
            warnings.append(
                f"Unable to decrypt {secrets_path}; skipped secret sync"
            )
    else:
        warnings.append(
            f"Secrets file not found at {secrets_path}; skipped secret sync"
        )

    if secrets_data:
        mattermost = secrets_data.get("mattermost", {})
        gitlab = secrets_data.get("gitlab", {})
        oidc = secrets_data.get("oidc", {})

        secret_items = [
            ("mattermost/admin-username", mattermost.get("admin-username"), "root", "root", "0400", None),
            ("mattermost/admin-email", mattermost.get("admin-email"), "root", "root", "0400", None),
            ("mattermost/admin-password", mattermost.get("admin-password"), "root", "root", "0400", None),
            ("mattermost/env", mattermost.get("env"), "mattermost", "mattermost", "0600", "mattermost.service"),
            ("oidc/chat-control-client-secret", oidc.get("chat-control-client-secret"), "root", "root", "0400", None),
            ("gitlab/api-token", gitlab.get("api-token"), "root", "root", "0400", None),
            (
                "gitlab/oauth-provider-client-secret",
                gitlab.get("oauth-provider-client-secret"),
                "root",
                "root",
                "0400",
                None,
            ),
        ]

        entries = []
        for name, content, owner, group, mode, restart in secret_items:
            if not content:
                continue
            entries.append(
                {
                    "name": name,
                    "remote_path": f"/run/secrets/{name}",
                    "content": content,
                    "owner": owner,
                    "group": group,
                    "mode": mode,
                    "restart_service": restart,
                }
            )

        if entries:
            secret_result = vm_manager.install_secret_files(company_name, entries)
            if not secret_result.get("success"):
                return {
                    "success": False,
                    "error": secret_result.get("error", "Failed to install secrets"),
                    "age_remote_path": age_remote_path,
                }

            installed_secrets = [entry["name"] for entry in entries]

        if restart_db:
            admin_password = mattermost.get("admin-password")
            if admin_password:
                db_result = vm_manager.ensure_mattermost_database(
                    company_name, admin_password
                )
                if db_result.get("success"):
                    messages.append("Mattermost database credentials refreshed")
                else:
                    warnings.append(
                        f"Mattermost database reset failed: {db_result.get('error')}"
                    )

    return {
        "success": True,
        "age_remote_path": age_remote_path,
        "messages": messages,
        "warnings": warnings,
        "installed_secrets": installed_secrets,
    }

@secrets.command(name="install")
@click.argument("company_name")
@click.option(
    "--key-file",
    default=str(DEFAULT_AGE_KEY_PATH),
    show_default=True,
    help="Age private key to copy into the VM"
)
@click.option(
    "--remote-path",
    default="/var/lib/sops-nix/key.txt",
    show_default=True,
    help="Destination path inside the VM"
)
@click.pass_context
@click.option(
    "--secrets-file",
    default=str(DEFAULT_SECRETS_FILE),
    show_default=True,
    help="Path to the encrypted secrets file"
)
def install_key(ctx, company_name: str, key_file: str, remote_path: str, secrets_file: str):
    """Copy the Age key into a running VM for sops-nix."""

    vm_manager = ctx.obj['vm_manager']
    sync_result = _sync_vm_secrets(
        vm_manager,
        company_name,
        Path(key_file),
        Path(secrets_file),
        restart_db=True,
    )

    if not sync_result.get("success"):
        click.echo(f"‚ùå {sync_result.get('error', 'Failed to install Age key')}" )
        sys.exit(1)

    age_remote_path = sync_result.get("age_remote_path", remote_path)
    click.echo(
        f"‚úÖ Age key installed for '{company_name}' at {age_remote_path}"
    )

    installed = sync_result.get("installed_secrets", [])
    if installed:
        click.echo(f"   ‚Ä¢ Installed secrets: {', '.join(installed)}")

    for message in sync_result.get("messages", []):
        click.echo(f"   ‚Ä¢ {message}")

    for warning in sync_result.get("warnings", []):
        click.echo(f"‚ö†Ô∏è {warning}")

# System Commands
@cli.command()
@click.pass_context
def prerequisites(ctx):
    """Check system prerequisites for RAVE operations."""
    vm_manager = ctx.obj['vm_manager']
    
    click.echo("üîç Checking RAVE system prerequisites...")
    
    result = vm_manager.check_prerequisites()
    
    if result['success']:
        click.echo("‚úÖ All prerequisites satisfied!")
    else:
        click.echo("‚ùå Missing prerequisites:")
        for item in result['missing']:
            click.echo(f"   ‚Ä¢ {item}")
    
    if result['warnings']:
        click.echo("‚ö†Ô∏è  Warnings:")
        for warning in result['warnings']:
            click.echo(f"   ‚Ä¢ {warning}")
    
    if not result['success']:
        click.echo("\nüìñ See docs/MACOS-SETUP.md for installation instructions")
        sys.exit(1)

# VM Management Commands
@cli.group()
def vm():
    """Virtual Machine management commands."""
    pass

@vm.command()
@click.argument('company_name')
@click.option('--keypair', required=True, help='Path to SSH keypair for VM access')
@click.pass_context
def create(ctx, company_name: str, keypair: str):
    """Create a new company development environment VM."""
    vm_manager = ctx.obj['vm_manager']
    
    click.echo(f"üöÄ Creating development environment for {company_name}...")
    click.echo(f"üîë Using SSH keypair: {keypair}")
    
    try:
        result = vm_manager.create_vm(company_name, keypair)
        if result['success']:
            click.echo(f"‚úÖ VM '{company_name}' created successfully!")
            click.echo(f"   SSH access: rave vm ssh {company_name}")
            click.echo(f"   Status: rave vm status {company_name}")
        else:
            click.echo(f"‚ùå Failed to create VM: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error creating VM: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name')
@click.pass_context
def start(ctx, company_name: str):
    """Start a company VM."""
    vm_manager = ctx.obj['vm_manager']
    
    click.echo(f"‚ñ∂Ô∏è  Starting VM '{company_name}'...")
    try:
        result = vm_manager.start_vm(company_name)
        if result['success']:
            click.echo(f"‚úÖ VM '{company_name}' started successfully!")

            sync_result = _sync_vm_secrets(
                vm_manager,
                company_name,
                DEFAULT_AGE_KEY_PATH,
                DEFAULT_SECRETS_FILE,
                restart_db=False,
            )

            if sync_result.get("success"):
                age_remote_path = sync_result.get(
                    "age_remote_path", "/var/lib/sops-nix/key.txt"
                )
                click.echo(f"   ‚Ä¢ SOPS Age key synced to {age_remote_path}")

                installed = sync_result.get("installed_secrets", [])
                if installed:
                    click.echo(
                        f"   ‚Ä¢ Deployed secrets: {', '.join(installed)}"
                    )

                for message in sync_result.get("messages", []):
                    click.echo(f"   ‚Ä¢ {message}")

                for warning in sync_result.get("warnings", []):
                    click.echo(f"   ‚ö†Ô∏è  {warning}")
            else:
                click.echo(
                    f"‚ö†Ô∏è  Secrets not synced automatically: {sync_result.get('error')}"
                )
                click.echo(
                    f"   Run 'rave secrets install {company_name}' after the key is available."
                )
        else:
            click.echo(f"‚ùå Failed to start VM: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error starting VM: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name')
@click.pass_context
def stop(ctx, company_name: str):
    """Stop a company VM."""
    vm_manager = ctx.obj['vm_manager']
    
    click.echo(f"‚èπÔ∏è  Stopping VM '{company_name}'...")
    try:
        result = vm_manager.stop_vm(company_name)
        if result['success']:
            click.echo(f"‚úÖ VM '{company_name}' stopped successfully!")
        else:
            click.echo(f"‚ùå Failed to stop VM: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error stopping VM: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name', required=False)
@click.option('--all', is_flag=True, help='Show status of all VMs')
@click.pass_context
def status(ctx, company_name: Optional[str], all: bool):
    """Show VM status."""
    vm_manager = ctx.obj['vm_manager']
    
    try:
        if all or not company_name:
            results = vm_manager.status_all_vms()
            if not results:
                click.echo("No VMs found.")
                return
                
            click.echo("üñ•Ô∏è  VM Status Overview:")
            for vm_name, status in results.items():
                status_icon = "üü¢" if status['running'] else "üî¥"
                click.echo(f"   {status_icon} {vm_name}: {status['status']}")
        else:
            result = vm_manager.status_vm(company_name)
            if result['success']:
                status_icon = "üü¢" if result['running'] else "üî¥"
                click.echo(f"{status_icon} VM '{company_name}': {result['status']}")
                if result['running']:
                    click.echo(f"   SSH: rave vm ssh {company_name}")
                    click.echo(f"   Logs: rave vm logs {company_name}")
            else:
                click.echo(f"‚ùå VM '{company_name}' not found")
                sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting VM status: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name')
@click.pass_context
def reset(ctx, company_name: str):
    """Reset VM to clean default state."""
    vm_manager = ctx.obj['vm_manager']
    
    click.echo(f"üîÑ Resetting VM '{company_name}' to default state...")
    if not click.confirm("This will reset all data in the VM. Continue?"):
        click.echo("Reset cancelled.")
        return
    
    try:
        result = vm_manager.reset_vm(company_name)
        if result['success']:
            click.echo(f"‚úÖ VM '{company_name}' reset successfully!")
            warning = result.get('warning')
            if warning:
                click.echo(f"‚ö†Ô∏è  {warning}")
        else:
            click.echo(f"‚ùå Failed to reset VM: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error resetting VM: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name')
@click.pass_context
def ssh(ctx, company_name: str):
    """SSH into company VM."""
    vm_manager = ctx.obj['vm_manager']
    
    try:
        result = vm_manager.ssh_vm(company_name)
        if not result['success']:
            click.echo(f"‚ùå {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error connecting to VM: {e}")
        sys.exit(1)

@vm.command()
@click.argument('company_name')
@click.argument('service', required=False)
@click.option('--follow', '-f', is_flag=True, help='Follow log output')
@click.option('--tail', '-t', default=50, help='Number of lines to show')
@click.option('--since', '-s', help='Show logs since time (e.g., 1h, 30m)')
@click.option('--all', is_flag=True, help='Show logs from all services')
@click.pass_context
def logs(ctx, company_name: str, service: Optional[str], follow: bool, tail: int, since: Optional[str], all: bool):
    """View VM service logs."""
    vm_manager = ctx.obj['vm_manager']
    
    try:
        result = vm_manager.get_logs(
            company_name, 
            service=service, 
            follow=follow, 
            tail=tail, 
            since=since, 
            all_services=all
        )
        if not result['success']:
            click.echo(f"‚ùå {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting logs: {e}")
        sys.exit(1)

# User Management Commands
@cli.group()
def user():
    """User management commands."""
    pass

@user.command()
@click.argument('email')
@click.option('--oauth-id', required=True, help='GitLab OAuth ID')
@click.option('--access', default='developer', help='Access level (admin/developer/guest)')
@click.option('--company', help='Company name')
@click.option('--name', help='Display name')
@click.option(
    '--metadata',
    help='User metadata (JSON object or comma-separated key=value pairs)',
)
@click.option(
    '--provider',
    help='OAuth provider (google or github). Defaults to configured provider.',
)
@click.pass_context
def add(
    ctx,
    email: str,
    oauth_id: str,
    access: str,
    company: Optional[str],
    name: Optional[str],
    metadata: Optional[str],
    provider: Optional[str],
):
    """Add a new user via GitLab OAuth."""
    user_manager = ctx.obj['user_manager']
    metadata_dict = _parse_metadata_option(metadata)

    default_provider = _get_default_provider(ctx)
    normalized_provider = _normalize_provider_choice(provider, default_provider)
    user_manager.set_default_provider(normalized_provider)

    provider_label = user_manager._provider_label(normalized_provider)
    click.echo(f"üë§ Adding user {email} (OAuth ID: {oauth_id}) via {provider_label}...")
    try:
        result = user_manager.add_user(
            email,
            oauth_id,
            access,
            company,
            name=name,
            metadata=metadata_dict,
            provider=normalized_provider,
        )
        if result['success']:
            click.echo(f"‚úÖ User {email} added successfully!")
        else:
            click.echo(f"‚ùå Failed to add user: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error adding user: {e}")
        sys.exit(1)

@user.command()
@click.argument('email')
@click.pass_context
def remove(ctx, email: str):
    """Remove a user."""
    user_manager = ctx.obj['user_manager']
    
    click.echo(f"üóëÔ∏è  Removing user {email}...")
    if not click.confirm(f"Remove user {email}?"):
        click.echo("User removal cancelled.")
        return
    
    try:
        result = user_manager.remove_user(email)
        if result['success']:
            click.echo(f"‚úÖ User {email} removed successfully!")
        else:
            click.echo(f"‚ùå Failed to remove user: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error removing user: {e}")
        sys.exit(1)

@user.command()
@click.option('--company', help='Filter by company')
@click.pass_context
def list(ctx, company: Optional[str]):
    """List all users."""
    user_manager = ctx.obj['user_manager']
    
    user_manager.set_default_provider(_get_default_provider(ctx))

    try:
        result = user_manager.list_users(company)
        if result['success']:
            users = result['users']
            if not users:
                click.echo("No users found.")
                return
                
            click.echo("üë• Users:")
            for user in users:
                company_info = f" ({user['company']})" if user.get('company') else ""
                display_name = f"{user.get('name')} " if user.get('name') else ""
                provider_label = user_manager._provider_label(user.get('provider'))
                provider_text = f" [{provider_label}]" if provider_label else ""
                click.echo(
                    f"   ‚Ä¢ {display_name}{user['email']}{company_info} - {user['access']}{provider_text}"
                )
        else:
            click.echo(f"‚ùå Failed to list users: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error listing users: {e}")
        sys.exit(1)

@user.command()
@click.argument('email')
@click.option('--access', help='New access level (admin/developer/guest)')
@click.pass_context
def config(ctx, email: str, access: Optional[str]):
    """Configure user settings."""
    user_manager = ctx.obj['user_manager']
    
    if not access:
        click.echo("No configuration options provided.")
        return
    
    click.echo(f"‚öôÔ∏è  Configuring user {email}...")
    try:
        result = user_manager.config_user(email, access=access)
        if result['success']:
            click.echo(f"‚úÖ User {email} configured successfully!")
        else:
            click.echo(f"‚ùå Failed to configure user: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error configuring user: {e}")
        sys.exit(1)

@user.command()
@click.argument('email')
@click.pass_context
def show(ctx, email: str):
    """Show user details."""
    user_manager = ctx.obj['user_manager']
    
    user_manager.set_default_provider(_get_default_provider(ctx))

    try:
        result = user_manager.get_user(email)
        if result['success']:
            user = result['user']
            click.echo(f"üë§ User Details:")
            if user.get('name'):
                click.echo(f"   Name: {user['name']}")
            click.echo(f"   Email: {user['email']}")
            click.echo(f"   OAuth ID: {user['oauth_id']}")
            click.echo(f"   Access: {user['access']}")
            click.echo(f"   Provider: {user_manager._provider_label(user.get('provider'))}")
            if user.get('company'):
                click.echo(f"   Company: {user['company']}")
            metadata = user.get('metadata')
            if metadata:
                click.echo("   Metadata:")
                for key, value in metadata.items():
                    click.echo(f"      - {key}: {value}")
        else:
            click.echo(f"‚ùå User {email} not found")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting user: {e}")
        sys.exit(1)

@user.command(name='bulk-add')
@click.argument('file', type=click.Path(exists=True))
@click.option('--company', help='Company name for all users')
@click.option(
    '--metadata',
    help='Default metadata applied to each user (JSON or comma-separated key=value pairs)',
)
@click.option(
    '--verbose',
    is_flag=True,
    help='Show per-user results during import',
)
@click.option(
    '--provider',
    help='OAuth provider for imported users (google or github).'
)
@click.pass_context
def bulk_add(
    ctx,
    file: str,
    company: Optional[str],
    metadata: Optional[str],
    verbose: bool,
    provider: Optional[str],
):
    """Add multiple users from CSV/JSON file."""
    user_manager = ctx.obj['user_manager']
    
    click.echo(f"üìÅ Adding users from {file}...")
    try:
        default_metadata = None
        if metadata is not None:
            parsed = _parse_metadata_option(metadata)
            default_metadata = parsed or None

        default_provider = _normalize_provider_choice(provider, _get_default_provider(ctx))
        user_manager.set_default_provider(default_provider)

        result = user_manager.bulk_add_users(
            file,
            company,
            default_metadata=default_metadata,
            provider=default_provider,
        )
        if result['success']:
            added_count = result.get('added', 0)
            updated_count = result.get('updated', 0)

            click.echo(f"‚úÖ Added {added_count} users successfully!")
            if updated_count:
                click.echo(f"üîÅ Updated {updated_count} existing users.")

            if verbose:
                details = result.get('details', {})
                for user in details.get('added', []):
                    email = user.get('email', 'unknown')
                    click.echo(f"   ‚Ä¢ Added {email}")
                for user in details.get('updated', []):
                    email = user.get('email', 'unknown')
                    click.echo(f"   ‚Ä¢ Updated {email}")
                for skipped in details.get('skipped', []):
                    email = skipped.get('email', 'unknown')
                    reason = skipped.get('reason', 'Skipped')
                    click.echo(f"   ‚Ä¢ Skipped {email}: {reason}")
                for failure in details.get('failed', []):
                    email = failure.get('email') or failure.get('data', {}).get('email', 'unknown')
                    error_msg = failure.get('error', 'Unknown error')
                    click.echo(f"   ‚Ä¢ Failed {email}: {error_msg}")

            if result['skipped']:
                click.echo(
                    f"‚ÑπÔ∏è  Skipped {result['skipped']} users."
                )
            if result['failed']:
                click.echo(
                    f"‚ö†Ô∏è  {result['failed']} users failed to add (see logs)"
                )
        else:
            click.echo(f"‚ùå Failed to bulk add users: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error bulk adding users: {e}")
        sys.exit(1)

@user.command()
@click.argument('email')
@click.pass_context
def activity(ctx, email: str):
    """Show user activity from GitLab."""
    user_manager = ctx.obj['user_manager']
    
    click.echo(f"üìä Getting activity for {email}...")
    try:
        result = user_manager.get_user_activity(email)
        if result['success']:
            activity = result['activity']
            if not activity:
                click.echo("No activity found.")
                return
                
            click.echo(f"üìà Recent Activity for {email}:")
            for item in activity[:10]:  # Show last 10 activities
                click.echo(f"   ‚Ä¢ {item.get('created_at', 'N/A')} - {item.get('action_name', 'Unknown')}")
        else:
            click.echo(f"‚ùå Failed to get activity: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting activity: {e}")
        sys.exit(1)

@user.command()
@click.argument('email')
@click.pass_context
def permissions(ctx, email: str):
    """Show user permissions across projects."""
    user_manager = ctx.obj['user_manager']
    
    click.echo(f"üîë Getting permissions for {email}...")
    try:
        result = user_manager.get_user_permissions(email)
        if result['success']:
            permissions = result['permissions']
            if not permissions:
                click.echo("No project permissions found.")
                return
                
            click.echo(f"üîí Project Permissions for {email}:")
            for perm in permissions:
                access_level = perm.get('access_level', 'Unknown')
                project_name = perm.get('project_name', 'Unknown Project')
                click.echo(f"   ‚Ä¢ {project_name}: {access_level}")
        else:
            click.echo(f"‚ùå Failed to get permissions: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting permissions: {e}")
        sys.exit(1)

@user.command()
@click.pass_context
def sync(ctx):
    """Sync local users with GitLab."""
    user_manager = ctx.obj['user_manager']
    
    click.echo("üîÑ Syncing users with GitLab...")
    try:
        result = user_manager.sync_users_with_gitlab()
        if result['success']:
            synced = result['synced']
            added = result['added']
            updated = result['updated']
            click.echo(f"‚úÖ Sync complete!")
            click.echo(f"   Synced: {synced} users")
            click.echo(f"   Added: {added} new users")
            click.echo(f"   Updated: {updated} users")
        else:
            click.echo(f"‚ùå Failed to sync users: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error syncing users: {e}")
        sys.exit(1)

@user.command()
@click.argument('file', type=click.Path())
@click.option('--format', type=click.Choice(['csv', 'json']), default='csv', help='Export format')
@click.option('--company', help='Filter by company')
@click.pass_context
def export(ctx, file: str, format: str, company: Optional[str]):
    """Export users to CSV/JSON file."""
    user_manager = ctx.obj['user_manager']
    
    click.echo(f"üì§ Exporting users to {file} ({format})...")
    try:
        result = user_manager.export_users(file, format, company)
        if result['success']:
            exported = result['exported']
            click.echo(f"‚úÖ Exported {exported} users to {file}")
        else:
            click.echo(f"‚ùå Failed to export users: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error exporting users: {e}")
        sys.exit(1)

# OAuth Management Commands
@cli.group()
def oauth():
    """OAuth configuration commands."""
    pass

@oauth.command()
@click.argument('service', type=click.Choice(['penpot', 'element']))
@click.option('--provider', default='gitlab', help='OAuth provider')
@click.option('--client-id', required=True, help='OAuth client ID')
@click.option('--client-secret', required=True, help='OAuth client secret')
@click.option('--redirect-uri', help='OAuth redirect URI')
@click.pass_context
def config(ctx, service: str, provider: str, client_id: str, client_secret: str, redirect_uri: Optional[str]):
    """Configure OAuth for services."""
    oauth_manager = ctx.obj['oauth_manager']
    
    click.echo(f"üîê Configuring {service} OAuth with {provider}...")
    try:
        result = oauth_manager.configure_service(
            service, provider, client_id, client_secret, redirect_uri
        )
        if result['success']:
            click.echo(f"‚úÖ OAuth configured for {service}!")
        else:
            click.echo(f"‚ùå Failed to configure OAuth: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error configuring OAuth: {e}")
        sys.exit(1)


@oauth.command('redirects')
@click.argument('company', required=False)
@click.option(
    '--provider',
    type=click.Choice(['google', 'github']),
    help='Limit output to a single provider',
)
@click.option(
    '--host', 'extra_hosts', multiple=True,
    help='Extra hostnames or base URLs (e.g. chat.example.com or https://gitlab.example.com:10443)',
)
@click.option(
    '--include-loopback/--no-loopback',
    default=True,
    help='Include localhost/127.0.0.1 callback URLs (default: include)',
)
@click.pass_context
def oauth_redirects(ctx, company: Optional[str], provider: Optional[str],
                    extra_hosts: List[str], include_loopback: bool):
    """Show redirect URIs needed by Google/GitHub OAuth clients."""

    vm_manager: VMManager = ctx.obj['vm_manager']

    company_names = [company] if company else _list_company_names()
    if not company_names:
        click.echo("No VM definitions found. Use 'rave vm create' first.")
        return

    provider_keys = [provider] if provider else builtins.list(PROVIDER_META.keys())

    for name in company_names:
        config = _load_company_config_or_exit(vm_manager, name)
        ports = config.get('ports') or {}
        https_port = ports.get('https')
        if not https_port:
            click.echo(f"‚ùå VM '{name}' has no HTTPS port mapping in the local config.")
            continue

        click.echo(f"üîó {name} (HTTPS :{https_port}):")

        host_list, _ = _build_redirect_hosts_and_uris(
            DEFAULT_PROVIDER_SLUG,
            https_port,
            builtins.list(extra_hosts),
            include_loopback=include_loopback,
        )
        if host_list:
            click.echo("  Suggested origins:")
            for host in host_list:
                click.echo(f"    - {host}")

        for provider_key in provider_keys:
            meta = PROVIDER_META[provider_key]
            _, redirect_uris = _build_redirect_hosts_and_uris(
                meta['slug'],
                https_port,
                builtins.list(extra_hosts),
                include_loopback=include_loopback,
            )
            click.echo(f"  {meta['label']} redirect URIs:")
            for uri in redirect_uris:
                click.echo(f"    - {uri}")

        click.echo()


@oauth.command('bootstrap')
@click.argument('provider', type=click.Choice(['google', 'github']))
@click.option('--company', help='Company VM name (defaults to sole VM if only one exists)')
@click.option('--project', help='Google Cloud project ID for the OAuth client (gcloud --project)')
@click.option('--client-name', help='Identifier for the OAuth client (defaults to rave-<company>-gitlab)')
@click.option('--host', 'extra_hosts', multiple=True, help='Additional hostnames/base URLs to include')
@click.option('--include-loopback/--no-loopback', default=True, help='Include localhost/127.0.0.1 redirect URIs')
@click.option('--run', is_flag=True, help='Execute the generated command instead of printing it')
@click.pass_context
def oauth_bootstrap(ctx, provider: str, company: Optional[str], project: Optional[str],
                    client_name: Optional[str], extra_hosts: List[str],
                    include_loopback: bool, run: bool):
    """Generate helper commands for provisioning Google/GitHub OAuth clients."""

    vm_manager: VMManager = ctx.obj['vm_manager']

    company_names = _list_company_names()
    if not company_names:
        raise click.ClickException("No VM definitions found. Create one with 'rave vm create'.")

    target_company = company
    if not target_company:
        if len(company_names) == 1:
            target_company = company_names[0]
        else:
            raise click.ClickException(
                "Multiple VMs detected; pass --company <name> to choose one."
            )

    config = _load_company_config_or_exit(vm_manager, target_company)
    https_port = (config.get('ports') or {}).get('https')
    if not https_port:
        raise click.ClickException(
            f"VM '{target_company}' is missing an HTTPS port mapping in ~/.config/rave/vms/{target_company}.json"
        )

    meta = PROVIDER_META[provider]

    hosts, redirect_uris = _build_redirect_hosts_and_uris(
        meta['slug'],
        https_port,
        builtins.list(extra_hosts),
        include_loopback=include_loopback,
    )

    if provider == 'google':
        suggested_name = client_name or f"rave-{target_company}-gitlab"
        display_name = f"RAVE GitLab ({target_company})"
        command_text = _render_gcloud_command(
            project,
            suggested_name,
            display_name,
            redirect_uris,
            meta['scopes'],
        )

        click.echo("üöÄ Google Cloud OAuth client helper:")
        click.echo(command_text)
        click.echo()
        click.echo("After creation, capture the client ID & secret (the command prints them).")
        click.echo("Store the secret via: sops --set '[\"gitlab\"][\"oauth-provider-client-secret\"]' 'SECRET' config/secrets.yaml")
        click.echo(
            f"Then apply them to the running VM with: rave oauth apply --company {target_company} --provider google --client-id <ID>"
        )

        if run:
            if shutil.which('gcloud') is None:
                raise click.ClickException("gcloud is not installed in PATH; cannot execute command.")
            click.echo("Executing gcloud command...")
            result = subprocess.run(command_text, shell=True)
            if result.returncode != 0:
                raise click.ClickException("gcloud command failed; inspect the output above.")

    else:
        click.echo("‚ÑπÔ∏è  GitHub does not expose a public API to create OAuth Apps via gh.")
        click.echo("Use https://github.com/settings/developers to create a new OAuth App with:")
        click.echo(f"  ‚Ä¢ Application name: RAVE GitLab ({target_company})")
        click.echo("  ‚Ä¢ Homepage URL: https://localhost:{https_port}/gitlab")
        click.echo("  ‚Ä¢ Authorization callback URL(s):")
        for uri in redirect_uris:
            click.echo(f"    - {uri}")
        click.echo()
        click.echo("After creation, grab the Client ID/Secret and run 'rave oauth apply --provider github ...'.")
        if run:
            click.echo("‚ö†Ô∏è  Ignoring --run because GitHub OAuth Apps cannot be provisioned via gh today.")

    if hosts:
        click.echo()
        click.echo("Suggested trusted origins (Google UI ‚Üí Authorized JavaScript origins):")
        for host in hosts:
            click.echo(f"  - {host}")


@oauth.command('apply')
@click.option('--company', required=True, help='Target company VM name')
@click.option('--provider', type=click.Choice(['google', 'github']), required=True)
@click.option(
    '--client-id',
    help='OAuth client ID from the provider (auto-detects GOOGLE_OAUTH_CLIENT_ID / GITHUB_OAUTH_CLIENT_ID)',
)
@click.option(
    '--client-secret',
    help='Client secret from the provider (reads GOOGLE_OAUTH_CLIENT_SECRET / GITHUB_OAUTH_CLIENT_SECRET when available)',
)
@click.option('--no-secret-sync', is_flag=True, help='Skip pushing the secret into /run/secrets')
@click.option('--auto-sign-in/--no-auto-sign-in', default=True, help='Toggle GitLab auto sign-in redirect')
@click.pass_context
def oauth_apply(ctx, company: str, provider: str, client_id: Optional[str], client_secret: Optional[str],
                no_secret_sync: bool, auto_sign_in: bool):
    """Apply provider credentials to the running GitLab instance."""

    vm_manager: VMManager = ctx.obj['vm_manager']
    user_manager: UserManager = ctx.obj['user_manager']

    config = _load_company_config_or_exit(vm_manager, company)
    if not vm_manager._is_vm_running(company):
        raise click.ClickException(
            f"VM '{company}' is not running. Start it with 'rave vm start {company}'."
        )

    meta = PROVIDER_META[provider]

    env_keys = PROVIDER_ENV_VARS.get(provider) or PROVIDER_ENV_VARS.get(meta['slug'])
    env_client_id = None
    env_client_secret = None
    env_key_id = None
    env_key_secret = None
    if env_keys:
        env_key_id, env_key_secret = env_keys
        env_client_id = os.environ.get(env_key_id)
        env_client_secret = os.environ.get(env_key_secret)

    if client_id:
        client_id = client_id.strip()
    if not client_id and env_client_id:
        client_id = env_client_id.strip()
        if env_key_id:
            click.echo(f"üîê Using OAuth client ID from {env_key_id}")
    if not client_id:
        client_id = click.prompt('OAuth client ID', type=str)
        client_id = client_id.strip()

    if client_secret:
        client_secret = client_secret.strip()
    if not client_secret and env_client_secret:
        client_secret = env_client_secret.strip()
        if env_key_secret:
            click.echo(f"üîê Using OAuth client secret from {env_key_secret}")
    if not client_secret:
        client_secret = click.prompt(
            'OAuth client secret',
            hide_input=True,
            confirmation_prompt=True,
        ).strip()

    if not client_id:
        raise click.ClickException("OAuth client ID is required.")
    if not client_secret:
        raise click.ClickException("OAuth client secret is required.")

    secret_path = "/run/secrets/gitlab/oauth-provider-client-secret"
    gitlab_secret_mode = "file"
    if not no_secret_sync:
        secret_result = vm_manager.install_secret_file(
            company,
            secret_path,
            client_secret,
            "root",
            "root",
            "0400",
        )
        if not secret_result.get('success'):
            raise click.ClickException(secret_result.get('error', 'Failed to copy client secret into VM'))
    else:
        gitlab_secret_mode = "inline"

    provider_args = dict(meta["args"])

    gitlab_payload = {
        "slug": meta["slug"],
        "label": meta["label"],
        "args": provider_args,
        "client_id": client_id,
        "secret_path": secret_path if gitlab_secret_mode == "file" else None,
        "client_secret": client_secret if gitlab_secret_mode != "file" else None,
    }

    ports = config.get("ports") or {}
    https_port = ports.get("https")
    if https_port:
        site_url = f"https://localhost:{https_port}"
    else:
        site_url = "https://localhost"

    mattermost_payload: Dict[str, Any] = {
        "provider": provider,
        "client_id": client_id,
        "client_secret": client_secret,
        "site_url": site_url,
    }

    remote_payload = {
        "gitlab": gitlab_payload,
        "options": {
            "auto_sign_in": auto_sign_in,
            "allow_local_signin": not auto_sign_in,
        },
        "mattermost": mattermost_payload,
    }

    payload_json = json.dumps(remote_payload)
    payload_env = shlex.quote(payload_json)

    remote_script_template = """
        set -euo pipefail
        export RAVE_OAUTH_PAYLOAD=__PAYLOAD__
        cat <<'RUBY' | gitlab-rails runner -
        require 'json'
        require 'yaml'

        payload = JSON.parse(ENV.fetch('RAVE_OAUTH_PAYLOAD'))

        gitlab_cfg = payload.fetch('gitlab')
        gitlab_config_path = '/var/gitlab/state/config/gitlab.yml'
        gitlab_config = YAML.load_file(gitlab_config_path)
        production = gitlab_config['production'] ||= {}
        omniauth = production['omniauth'] ||= {}

        slug = gitlab_cfg.fetch('slug')
        provider_args = Marshal.load(Marshal.dump(gitlab_cfg.fetch('args')))
        provider_args['client_id'] = gitlab_cfg.fetch('client_id')

        if gitlab_cfg['secret_path']
          provider_args['client_secret'] = { '_secret' => gitlab_cfg['secret_path'] }
        elsif gitlab_cfg['client_secret']
          provider_args['client_secret'] = gitlab_cfg['client_secret']
        end

        provider_entry = {
          'name' => slug,
          'label' => gitlab_cfg.fetch('label'),
          'args' => provider_args
        }

        omniauth['enabled'] = true

        allow_single = Array(omniauth['allow_single_sign_on']).map(&:to_s)
        omniauth['allow_single_sign_on'] = (allow_single | [slug])

        auto_link = Array(omniauth['auto_link_user']).map(&:to_s)
        omniauth['auto_link_user'] = (auto_link | [slug])

        omniauth['block_auto_created_users'] = true

        providers = Array(omniauth['providers']).dup
        providers.reject! { |existing| existing.is_a?(Hash) && existing['name'] == slug }
        providers << provider_entry
        omniauth['providers'] = providers

        options = payload.fetch('options')
        if options['auto_sign_in']
          omniauth['auto_sign_in_with_provider'] = slug
        elsif omniauth['auto_sign_in_with_provider'] == slug
          omniauth.delete('auto_sign_in_with_provider')
        end

        allow_local = !!options['allow_local_signin']
        production['gitlab_signin_enabled'] = allow_local
        production['password_authentication_enabled_for_web'] = allow_local
        production['gitlab_signup_enabled'] = false

        File.write(gitlab_config_path, YAML.dump(gitlab_config))
RUBY

        python3 <<'PY'
import json
import os
from pathlib import Path

payload = json.loads(os.environ.get('RAVE_OAUTH_PAYLOAD', '{}'))
mattermost = payload.get('mattermost') or {}
config_path = Path('/var/lib/mattermost/config/config.json')
if config_path.exists():
    try:
        config = json.loads(config_path.read_text())
    except Exception as exc:
        raise SystemExit(f'Failed to load Mattermost config: {exc}')

    email = config.setdefault('EmailSettings', {})
    email['EnableSignUpWithEmail'] = False
    email['EnableSignInWithEmail'] = False
    email['EnableSignInWithUsername'] = False

    service = config.setdefault('ServiceSettings', {})
    service['EnableLocalMode'] = False
    site_url = mattermost.get('site_url')
    if site_url:
        service['SiteURL'] = site_url

    provider = (mattermost.get('provider') or '').lower()
    client_id = mattermost.get('client_id') or ''
    client_secret = mattermost.get('client_secret') or ''

    if provider == 'google':
        google = config.setdefault('GoogleSettings', {})
        google['Enable'] = True
        google['Id'] = client_id
        google['Secret'] = client_secret
        google.setdefault('Scope', 'profile email')
        google.setdefault('AuthEndpoint', 'https://accounts.google.com/o/oauth2/v2/auth')
        google.setdefault('TokenEndpoint', 'https://www.googleapis.com/oauth2/v4/token')
        google.setdefault('UserAPIEndpoint', 'https://people.googleapis.com/v1/people/me?personFields=names,emailAddresses,nicknames,metadata')

        github = config.setdefault('GitLabSettings', {})
        github['Enable'] = False
    elif provider == 'github':
        google = config.setdefault('GoogleSettings', {})
        google['Enable'] = False

        github = config.setdefault('GitLabSettings', {})
        github['Enable'] = True
        github['Id'] = client_id
        github['Secret'] = client_secret
        github['Scope'] = 'user:email'
        github['AuthEndpoint'] = 'https://github.com/login/oauth/authorize'
        github['TokenEndpoint'] = 'https://github.com/login/oauth/access_token'
        github['UserAPIEndpoint'] = 'https://api.github.com/user'
        github['DiscoveryEndpoint'] = ''
        github['ButtonText'] = 'GitHub'
        github['ButtonColor'] = '#24292e'
    else:
        google = config.setdefault('GoogleSettings', {})
        google['Enable'] = False
        github = config.setdefault('GitLabSettings', {})
        github['Enable'] = False

    with config_path.open('w') as handle:
        json.dump(config, handle, indent=2)
PY
        """

    remote_script = textwrap.dedent(remote_script_template).replace('__PAYLOAD__', payload_env)
    run_result = vm_manager._run_remote_script(
        config,
        remote_script,
        timeout=420,
        description="configuring OAuth services",
        max_attempts=3,
        initial_delay=2.0,
        connect_timeout=45,
    )

    if not run_result.get('success'):
        raise click.ClickException(run_result.get('error', 'Failed to configure OAuth services'))

    user_manager.set_default_provider(meta['slug'])
    click.echo(f"‚úÖ Applied {meta['label']} OAuth credentials to GitLab on VM '{company}'.")

@oauth.command()
@click.argument('service', required=False)
@click.pass_context
def status(ctx, service: Optional[str]):
    """Show OAuth configuration status."""
    oauth_manager = ctx.obj['oauth_manager']
    
    try:
        result = oauth_manager.get_status(service)
        if result['success']:
            configs = result['configs']
            if not configs:
                click.echo("No OAuth configurations found.")
                return
                
            click.echo("üîê OAuth Status:")
            for svc, config in configs.items():
                status_icon = "üü¢" if config['configured'] else "üî¥"
                click.echo(f"   {status_icon} {svc}: {config['provider']} - {config['status']}")
        else:
            click.echo(f"‚ùå Failed to get OAuth status: {result['error']}")
            sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error getting OAuth status: {e}")
        sys.exit(1)

if __name__ == '__main__':
    cli()
