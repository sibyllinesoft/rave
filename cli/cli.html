<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository Analysis: Scribe Analysis</title>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #b5b5b5;
            --text-muted: #888;
            --accent-primary: #4f9cf9;
            --accent-secondary: #7c3aed;
            --border-color: #404040;
            --hover-color: #333333;
            --code-bg: #252525;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.02);
            color: white;
            padding: 32px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.01) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3e%3cg fill='none' fill-rule='evenodd'%3e%3cg fill='%23ffffff' fill-opacity='0.02'%3e%3ccircle cx='20' cy='20' r='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e");
            pointer-events: none;
        }
        
        .header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }
        
        .header .meta {
            margin-top: 20px;
            opacity: 0.9;
            font-size: 13px;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .meta-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .stats {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
        }
        
        .stat {
            text-align: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }
        
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .toc {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .toc h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .file-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .file-item {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .file-item:hover {
            background-color: var(--hover-color);
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-name {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-meta {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .content {
            padding: 24px;
            background: var(--bg-secondary);
        }
        
        .file-section {
            margin-bottom: 32px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .file-header {
            background: var(--bg-tertiary);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-content {
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }
        
        .file-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .file-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .file-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .file-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        pre {
            margin: 0;
            padding: 24px;
            background: var(--code-bg);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-primary);
        }
        
        .icon {
            width: 16px;
            height: 16px;
        }
        
        .icon-lg {
            width: 20px;
            height: 20px;
        }

        /* React Tree Component Styles */
        .tree-container {
            height: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow-y: auto;
            padding: 8px;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            user-select: none;
            border-radius: 4px;
            margin: 1px 0;
        }

        .tree-node:hover {
            background: var(--hover-color);
            color: var(--accent-primary);
        }

        .tree-node.selected {
            background: var(--accent-primary);
            color: white;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            width: 100%;
        }

        .tree-arrow {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            opacity: 0.6;
        }

        .tree-arrow.expanded {
            transform: rotate(90deg);
        }

        .tree-arrow.hidden {
            opacity: 0;
        }

        .tree-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .tree-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .folder-icon {
            color: var(--accent-secondary);
        }

        .file-icon {
            color: var(--text-secondary);
        }

        /* Scrollbar styling for tree */
        .tree-container::-webkit-scrollbar {
            width: 8px;
        }

        .tree-container::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .tree-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header .meta {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .meta-item {
                justify-content: center;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 16px;
            }
            
            .content {
                padding: 16px;
            }
        }
        
        .control-bar {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .control-buttons {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: #3d8bfd;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--hover-color);
            transform: translateY(-1px);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.online {
            background: #10b981;
        }
        
        .status-dot.offline {
            background: #ef4444;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .control-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 16px;
            }
            
            .control-buttons {
                justify-content: center;
            }
            
            .status-indicator {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                🔍 Repository Analysis
            </h1>
            <div class="meta">
                <div class="meta-item">
                    <span>📊 <strong>Algorithm:</strong> v5-integrated</span>
                </div>
                <div class="meta-item">
                    <span>🕒 <strong>Generated:</strong> 2025-10-26 16:02:48 UTC</span>
                </div>
                <div class="meta-item">
                    <span>⚡ <strong>Selection Time:</strong> 71ms</span>
                </div>
            </div>
        </div>
        
        <div class="control-bar">
            <div class="control-buttons">
                <button id="save-btn" class="btn btn-primary">
                    💾 Save Bundle
                </button>
                <button id="shutdown-btn" class="btn btn-secondary">
                    🛑 Shutdown Server
                </button>
            </div>
            <div class="status-indicator">
                <span id="connection-status" class="status-dot online"></span>
                <span id="status-text">Connected</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">
                    📄 6
                </div>
                <div class="stat-label">Files Selected</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    🔢 17,783
                </div>
                <div class="stat-label">Estimated Tokens</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    💾 95.54 KB
                </div>
                <div class="stat-label">Total Size</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    🎯 120.0%
                </div>
                <div class="stat-label">Coverage</div>
            </div>
        </div>
        
        <div class="toc">
            <h3>
                📁 File Explorer
            </h3>
            <div id="file-tree-container" class="tree-container"></div>
        </div>
        
        <div class="file-list">
            <div class="file-item">
                <span class="file-name">📄 DIRECTORY_MAP.txt</span>
                <span class="file-meta">1.39 KB • ~364 tokens • Score: 1.00</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 vm_manager.py</span>
                <span class="file-meta">47.55 KB • ~8,927 tokens • Score: 0.88</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 platform_utils.py</span>
                <span class="file-meta">9.91 KB • ~1,911 tokens • Score: 0.88</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 user_manager.py</span>
                <span class="file-meta">29.89 KB • ~5,300 tokens • Score: 0.88</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 oauth_manager.py</span>
                <span class="file-meta">4.17 KB • ~774 tokens • Score: 0.83</span>
            </div>
            <div class="file-item">
                <span class="file-name">📄 README.md</span>
                <span class="file-meta">2.64 KB • ~507 tokens • Score: 0.28</span>
            </div>
        </div>
        
        <div class="content">
            <div class="file-section" id="file-1">
                <div class="file-header">📄 DIRECTORY_MAP.txt</div>
                <div class="file-content">
                    <pre>Repository Inventory
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
Path                                                         Type       Size Modified
------------------------------------------------------------ ---- ---------- -------------------
.                                                            dir    94.15 KB 2025-10-26 09:24:54
/                                                            dir     4.10 KB 2025-09-07 18:08:55
/home                                                        dir     32.00 B 2025-07-05 13:25:42
/home/nathan                                                 dir     2.27 KB 2025-10-26 07:49:01
/home/nathan/Projects                                        dir     1.20 KB 2025-10-17 21:11:39
/home/nathan/Projects/rave                                   dir     1.60 KB 2025-10-26 12:01:50
/home/nathan/Projects/rave/cli                               dir    368.00 B 2025-10-07 16:34:15
/home/nathan/Projects/rave/cli/README.md                     file    2.64 KB 2025-08-29 21:24:56
/home/nathan/Projects/rave/cli/oauth_manager.py              file    4.17 KB 2025-10-07 13:51:41
/home/nathan/Projects/rave/cli/platform_utils.py             file    9.91 KB 2025-10-05 07:05:36
/home/nathan/Projects/rave/cli/user_manager.py               file   29.89 KB 2025-10-09 17:44:31
/home/nathan/Projects/rave/cli/vm_manager.py                 file   47.55 KB 2025-10-26 09:24:54
</pre>
                </div>
            </div>
            <div class="file-section" id="file-2">
                <div class="file-header">📄 vm_manager.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;
VM Manager - Handles RAVE virtual machine lifecycle operations
&amp;quot;&amp;quot;&amp;quot;

import base64
import json
import shlex
import socket
import shutil
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Dict, List, Optional

from platform_utils import PlatformManager


class VMManager:
    &amp;quot;&amp;quot;&amp;quot;Manages RAVE virtual machine operations.&amp;quot;&amp;quot;&amp;quot;
    
    def __init__(self, vms_dir: Path):
        self.vms_dir &#x3D; vms_dir
        self.vms_dir.mkdir(parents&#x3D;True, exist_ok&#x3D;True)
        self.platform &#x3D; PlatformManager()
    
    def check_prerequisites(self) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Check if all required tools are available for VM operations.&amp;quot;&amp;quot;&amp;quot;
        return self.platform.check_prerequisites()
        
    def _get_vm_config_path(self, company_name: str) -&amp;gt; Path:
        &amp;quot;&amp;quot;&amp;quot;Get path to VM configuration file.&amp;quot;&amp;quot;&amp;quot;
        return self.vms_dir / f&amp;quot;{company_name}.json&amp;quot;
    
    def _load_vm_config(self, company_name: str) -&amp;gt; Optional[Dict]:
        &amp;quot;&amp;quot;&amp;quot;Load VM configuration.&amp;quot;&amp;quot;&amp;quot;
        config_path &#x3D; self._get_vm_config_path(company_name)
        if not config_path.exists():
            return None
        try:
            return json.loads(config_path.read_text())
        except (json.JSONDecodeError, FileNotFoundError):
            return None
    
    def _save_vm_config(self, company_name: str, config: Dict):
        &amp;quot;&amp;quot;&amp;quot;Save VM configuration.&amp;quot;&amp;quot;&amp;quot;
        config_path &#x3D; self._get_vm_config_path(company_name)
        config_path.write_text(json.dumps(config, indent&#x3D;2))

    def _build_ssh_command(
        self,
        config: Dict,
        remote_script: str,
        *,
        connect_timeout: int &#x3D; 10,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Construct an SSH command for running a remote script.&amp;quot;&amp;quot;&amp;quot;

        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        keypair_path &#x3D; config.get(&amp;quot;keypair&amp;quot;)

        ssh_common &#x3D; [
            &amp;quot;-o&amp;quot;,
            &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
            &amp;quot;-o&amp;quot;,
            &amp;quot;UserKnownHostsFile&#x3D;/dev/null&amp;quot;,
            &amp;quot;-p&amp;quot;,
            str(ports[&amp;quot;ssh&amp;quot;]),
            &amp;quot;root@localhost&amp;quot;,
            &amp;quot;bash&amp;quot;,
            &amp;quot;-lc&amp;quot;,
            remote_script,
        ]

        if keypair_path and Path(keypair_path).exists():
            command &#x3D; [&amp;quot;ssh&amp;quot;, &amp;quot;-i&amp;quot;, keypair_path, *ssh_common]
            return {&amp;quot;success&amp;quot;: True, &amp;quot;command&amp;quot;: command}

        if not shutil.which(&amp;quot;sshpass&amp;quot;):
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: &amp;quot;sshpass not available; provide an SSH keypair for VM access&amp;quot;,
            }

        command &#x3D; [
            &amp;quot;sshpass&amp;quot;,
            &amp;quot;-p&amp;quot;,
            &amp;quot;debug123&amp;quot;,
            &amp;quot;ssh&amp;quot;,
            *ssh_common,
        ]
        return {&amp;quot;success&amp;quot;: True, &amp;quot;command&amp;quot;: command}

    def _run_remote_script(
        self,
        config: Dict,
        remote_script: str,
        *,
        timeout: int,
        description: str,
        connect_timeout: int &#x3D; 10,
        max_attempts: int &#x3D; 5,
        initial_delay: float &#x3D; 1.0,
        max_delay: float &#x3D; 16.0,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Execute a remote script over SSH with exponential backoff.&amp;quot;&amp;quot;&amp;quot;

        delay &#x3D; initial_delay
        last_error &#x3D; &amp;quot;&amp;quot;

        for attempt in range(1, max_attempts + 1):
            build_result &#x3D; self._build_ssh_command(
                config, remote_script, connect_timeout&#x3D;connect_timeout
            )
            if not build_result.get(&amp;quot;success&amp;quot;):
                return build_result

            ssh_cmd &#x3D; build_result[&amp;quot;command&amp;quot;]

            try:
                result &#x3D; subprocess.run(
                    ssh_cmd,
                    capture_output&#x3D;True,
                    text&#x3D;True,
                    timeout&#x3D;timeout,
                )
            except subprocess.TimeoutExpired:
                last_error &#x3D; (
                    f&amp;quot;{description} attempt {attempt} timed out after {timeout} seconds&amp;quot;
                )
            else:
                if result.returncode &#x3D;&#x3D; 0:
                    return {&amp;quot;success&amp;quot;: True, &amp;quot;result&amp;quot;: result}

                stderr &#x3D; result.stderr.strip()
                stdout &#x3D; result.stdout.strip()
                last_error &#x3D; (
                    stderr
                    or stdout
                    or f&amp;quot;{description} failed with exit code {result.returncode}&amp;quot;
                )

            if attempt &amp;lt; max_attempts:
                time.sleep(delay)
                delay &#x3D; min(delay * 2, max_delay)

        return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: last_error or description}

    def _get_next_port_range(self) -&amp;gt; tuple:
        &amp;quot;&amp;quot;&amp;quot;Get next available port range for VM.&amp;quot;&amp;quot;&amp;quot;
        # Start from 8100 and increment by 10 for each VM
        existing_vms &#x3D; list(self.vms_dir.glob(&amp;quot;*.json&amp;quot;))
        base_port &#x3D; 8100 + (len(existing_vms) * 10)
        return (
            base_port,      # HTTP
            base_port + 1,  # HTTPS
            base_port + 2,  # SSH
            base_port + 3   # Test page
        )

    def _host_port_available(self, port: int) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;Check if a host TCP port is available for forwarding.&amp;quot;&amp;quot;&amp;quot;
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                sock.bind((&amp;quot;127.0.0.1&amp;quot;, port))
            except OSError:
                return False
        return True
    
    def _build_vm_image(self, company_name: str &#x3D; None, ssh_public_key: str &#x3D; None) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Build VM image using Nix.&amp;quot;&amp;quot;&amp;quot;
        try:
            # For now, custom company builds reuse the shared qcow2 artifact.
            nix_cmd &#x3D; self.platform.get_nix_build_command()
            nix_cmd.extend([&amp;quot;--show-trace&amp;quot;, &amp;quot;.#rave-qcow2&amp;quot;])

            result &#x3D; subprocess.run(
                nix_cmd,
                cwd&#x3D;Path.cwd(),
                capture_output&#x3D;True,
                text&#x3D;True,
            )

            warning: Optional[str] &#x3D; None

            if result.returncode !&#x3D; 0:
                warning &#x3D; (
                    &amp;quot;nix build .#rave-qcow2 failed; falling back to default build&amp;quot;
                )
                fallback_cmd &#x3D; self.platform.get_nix_build_command()
                fallback_cmd.extend([&amp;quot;--show-trace&amp;quot;])
                result &#x3D; subprocess.run(
                    fallback_cmd,
                    cwd&#x3D;Path.cwd(),
                    capture_output&#x3D;True,
                    text&#x3D;True,
                )
                if result.returncode !&#x3D; 0:
                    return {
                        &amp;quot;success&amp;quot;: False,
                        &amp;quot;error&amp;quot;: result.stderr.strip() or &amp;quot;Failed to build VM image&amp;quot;,
                    }

            result_dir &#x3D; Path.cwd() / &amp;quot;result&amp;quot;
            if not result_dir.exists():
                return {
                    &amp;quot;success&amp;quot;: True,
                    &amp;quot;image&amp;quot;: None,
                    &amp;quot;warning&amp;quot;: &amp;quot;nix build completed but no &amp;#39;result&amp;#39; symlink was created&amp;quot;,
                }

            candidates &#x3D; list(result_dir.glob(&amp;quot;*.qcow2&amp;quot;))
            if not candidates:
                return {
                    &amp;quot;success&amp;quot;: True,
                    &amp;quot;image&amp;quot;: None,
                    &amp;quot;warning&amp;quot;: &amp;quot;nix build produced no qcow2 artifacts&amp;quot;,
                }

            # Prefer a deterministic filename if present.
            image_path &#x3D; None
            for preferred in (&amp;quot;nixos.qcow2&amp;quot;, &amp;quot;disk.qcow2&amp;quot;, &amp;quot;image.qcow2&amp;quot;):
                candidate &#x3D; result_dir / preferred
                if candidate.exists():
                    image_path &#x3D; candidate
                    break
            if image_path is None:
                image_path &#x3D; candidates[0]

            response &#x3D; {&amp;quot;success&amp;quot;: True, &amp;quot;image&amp;quot;: image_path}
            if warning:
                response[&amp;quot;warning&amp;quot;] &#x3D; warning
            return response
        except Exception as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: str(e)}
    
    def _build_company_vm(self, company_name: str, ssh_public_key: str) -&amp;gt; subprocess.CompletedProcess:
        &amp;quot;&amp;quot;&amp;quot;Build a custom VM for a specific company with SSH key injection.&amp;quot;&amp;quot;&amp;quot;
        # For now, let&amp;#39;s use the standard development build and inject keys at runtime
        # This is simpler and more reliable than custom builds per company
        return subprocess.run([
            &amp;quot;nix&amp;quot;, &amp;quot;build&amp;quot;, &amp;quot;--show-trace&amp;quot;
        ], cwd&#x3D;&amp;quot;/home/nathan/Projects/rave&amp;quot;, capture_output&#x3D;True, text&#x3D;True)

    def _create_blank_disk(self, target: Path, size_gb: int &#x3D; 20) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Create a fresh QCOW2 disk image using qemu-img and mkfs.&amp;quot;&amp;quot;&amp;quot;

        qemu_img &#x3D; shutil.which(&amp;quot;qemu-img&amp;quot;)
        mkfs_ext4 &#x3D; shutil.which(&amp;quot;mkfs.ext4&amp;quot;)

        if not qemu_img or not mkfs_ext4:
            missing &#x3D; []
            if not qemu_img:
                missing.append(&amp;quot;qemu-img&amp;quot;)
            if not mkfs_ext4:
                missing.append(&amp;quot;mkfs.ext4&amp;quot;)
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: f&amp;quot;Required tooling missing: {&amp;#39;, &amp;#39;.join(missing)}&amp;quot;,
            }

        target.parent.mkdir(parents&#x3D;True, exist_ok&#x3D;True)

        raw_temp &#x3D; None
        try:
            with tempfile.NamedTemporaryFile(prefix&#x3D;&amp;quot;rave-disk-&amp;quot;, suffix&#x3D;&amp;quot;.raw&amp;quot;, delete&#x3D;False) as tmp:
                raw_temp &#x3D; Path(tmp.name)

            subprocess.run(
                [qemu_img, &amp;quot;create&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;raw&amp;quot;, str(raw_temp), f&amp;quot;{size_gb}G&amp;quot;],
                check&#x3D;True,
            )

            subprocess.run(
                [mkfs_ext4, &amp;quot;-F&amp;quot;, &amp;quot;-L&amp;quot;, &amp;quot;nixos&amp;quot;, str(raw_temp)],
                check&#x3D;True,
            )

            subprocess.run(
                [qemu_img, &amp;quot;convert&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;raw&amp;quot;, &amp;quot;-O&amp;quot;, &amp;quot;qcow2&amp;quot;, str(raw_temp), str(target)],
                check&#x3D;True,
            )

            target.chmod(0o644)
            return {&amp;quot;success&amp;quot;: True}
        except subprocess.CalledProcessError as exc:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: exc.stderr.strip() if exc.stderr else str(exc),
            }
        except Exception as exc:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: str(exc)}
        finally:
            if raw_temp and raw_temp.exists():
                try:
                    raw_temp.unlink()
                except OSError:
                    pass
    
    def _inject_ssh_key(self, image_path: str, ssh_public_key: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Inject SSH public key into VM image using guestfish.&amp;quot;&amp;quot;&amp;quot;
        try:
            # Use guestfish to modify the VM image
            # Escape the SSH key properly for guestfish
            escaped_key &#x3D; ssh_public_key.replace(&amp;#39;&amp;quot;&amp;#39;, &amp;#39;\\&amp;quot;&amp;#39;)
            guestfish_script &#x3D; f&amp;#39;&amp;#39;&amp;#39;launch
list-filesystems
mount /dev/sda1 /
mkdir-p /root/.ssh
write /root/.ssh/authorized_keys &amp;quot;{escaped_key}\\n&amp;quot;
chmod 0700 /root/.ssh
chmod 0600 /root/.ssh/authorized_keys
chown 0 0 /root/.ssh
chown 0 0 /root/.ssh/authorized_keys
sync
umount /
exit
&amp;#39;&amp;#39;&amp;#39;
            
            # Run guestfish with proper error handling
            result &#x3D; subprocess.run([
                &amp;quot;guestfish&amp;quot;, &amp;quot;--add&amp;quot;, image_path, &amp;quot;--rw&amp;quot;
            ], input&#x3D;guestfish_script, text&#x3D;True, capture_output&#x3D;True)
            
            if result.returncode !&#x3D; 0:
                print(f&amp;quot;Guestfish failed: {result.stderr}&amp;quot;)
                # Fallback: rely on runtime provisioning
                return self._inject_ssh_key_cloud_init(image_path, ssh_public_key)
            
            return {&amp;quot;success&amp;quot;: True, &amp;quot;method&amp;quot;: &amp;quot;guestfish&amp;quot;}
            
        except FileNotFoundError:
            # guestfish not available, use virt-customize approach
            return self._inject_ssh_key_cloud_init(image_path, ssh_public_key)
        except Exception as e:
            print(f&amp;quot;Guestfish exception: {e}&amp;quot;)
            return self._inject_ssh_key_cloud_init(image_path, ssh_public_key)

    def _install_age_key_into_image(self, image_path: str, age_key_path: Path) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Install the Age key into the VM image so secrets decrypt on first boot.&amp;quot;&amp;quot;&amp;quot;
        if not age_key_path.exists():
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Age key not found at {age_key_path}&amp;quot;}

        if shutil.which(&amp;quot;guestfish&amp;quot;) is None:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: &amp;quot;guestfish is not installed; install libguestfs-tools to embed the Age key during image build&amp;quot;,
            }

        temp_key_path: Optional[Path] &#x3D; None
        try:
            key_bytes &#x3D; age_key_path.read_bytes()
        except OSError as exc:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: f&amp;quot;Failed to read Age key: {exc}&amp;quot;,
            }

        try:
            with tempfile.NamedTemporaryFile(prefix&#x3D;&amp;quot;rave-age-key-&amp;quot;, delete&#x3D;False) as tmp:
                temp_key_path &#x3D; Path(tmp.name)
                tmp.write(key_bytes)
                tmp.flush()

            remote_path &#x3D; &amp;quot;/var/lib/sops-nix/key.txt&amp;quot;
            guestfish_script &#x3D; f&amp;#39;&amp;#39;&amp;#39;launch
list-filesystems
mount /dev/disk/by-label/nixos /
mkdir-p /var/lib/sops-nix
upload {temp_key_path} {remote_path}
chmod 0700 /var/lib/sops-nix
chmod 0400 {remote_path}
chown 0 0 /var/lib/sops-nix
chown 0 0 {remote_path}
sync
umount /
exit
&amp;#39;&amp;#39;&amp;#39;

            result &#x3D; subprocess.run(
                [&amp;quot;guestfish&amp;quot;, &amp;quot;--add&amp;quot;, image_path, &amp;quot;--rw&amp;quot;],
                input&#x3D;guestfish_script,
                text&#x3D;True,
                capture_output&#x3D;True,
            )
            if result.returncode !&#x3D; 0:
                stderr &#x3D; result.stderr.strip() if result.stderr else &amp;quot;&amp;quot;
                return {
                    &amp;quot;success&amp;quot;: False,
                    &amp;quot;error&amp;quot;: (
                        f&amp;quot;guestfish failed to install Age key&amp;quot;
                        + (f&amp;quot;: {stderr}&amp;quot; if stderr else &amp;quot;&amp;quot;)
                    ),
                }

            return {&amp;quot;success&amp;quot;: True}
        except subprocess.CalledProcessError as exc:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: exc.stderr.strip() if exc.stderr else str(exc),
            }
        finally:
            if temp_key_path and temp_key_path.exists():
                try:
                    temp_key_path.unlink()
                except OSError:
                    pass

    def _inject_ssh_key_simple(self, image_path: str, ssh_public_key: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;SSH key injection using loop mount approach.&amp;quot;&amp;quot;&amp;quot;
        try:
            import tempfile
            import os
            
            # Create a temporary mount point
            with tempfile.TemporaryDirectory() as temp_dir:
                mount_point &#x3D; os.path.join(temp_dir, &amp;quot;mnt&amp;quot;)
                os.makedirs(mount_point)
                
                # Get the partition offset using qemu-img
                result &#x3D; subprocess.run([
                    &amp;quot;qemu-img&amp;quot;, &amp;quot;info&amp;quot;, image_path
                ], capture_output&#x3D;True, text&#x3D;True)
                
                if result.returncode !&#x3D; 0:
                    return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to get image info: {result.stderr}&amp;quot;}
                
                # Try to mount the image directly
                # First convert to raw format temporarily if needed
                raw_image &#x3D; os.path.join(temp_dir, &amp;quot;temp.raw&amp;quot;)
                subprocess.run([
                    &amp;quot;qemu-img&amp;quot;, &amp;quot;convert&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;qcow2&amp;quot;, &amp;quot;-O&amp;quot;, &amp;quot;raw&amp;quot;, image_path, raw_image
                ], capture_output&#x3D;True, text&#x3D;True)
                
                # Try to mount as ext4 filesystem
                # Get partition table info
                result &#x3D; subprocess.run([
                    &amp;quot;parted&amp;quot;, &amp;quot;-m&amp;quot;, raw_image, &amp;quot;print&amp;quot;
                ], capture_output&#x3D;True, text&#x3D;True)
                
                if result.returncode &#x3D;&#x3D; 0:
                    # Parse partition info to find the root partition
                    lines &#x3D; result.stdout.strip().split(&amp;#39;\n&amp;#39;)
                    for line in lines[2:]:  # Skip header lines
                        parts &#x3D; line.split(&amp;#39;:&amp;#39;)
                        if len(parts) &amp;gt;&#x3D; 5 and (&amp;#39;ext&amp;#39; in parts[4] or &amp;#39;linux&amp;#39; in parts[5].lower()):
                            # Found a Linux partition, try to mount it
                            start_sector &#x3D; parts[1].rstrip(&amp;#39;s&amp;#39;)
                            try:
                                start_bytes &#x3D; int(start_sector) * 512
                                
                                # Mount with offset
                                mount_result &#x3D; subprocess.run([
                                    &amp;quot;sudo&amp;quot;, &amp;quot;mount&amp;quot;, &amp;quot;-o&amp;quot;, f&amp;quot;loop,offset&#x3D;{start_bytes}&amp;quot;, raw_image, mount_point
                                ], capture_output&#x3D;True, text&#x3D;True)
                                
                                if mount_result.returncode &#x3D;&#x3D; 0:
                                    # Successfully mounted, inject SSH key
                                    ssh_dir &#x3D; os.path.join(mount_point, &amp;quot;root&amp;quot;, &amp;quot;.ssh&amp;quot;)
                                    authorized_keys &#x3D; os.path.join(ssh_dir, &amp;quot;authorized_keys&amp;quot;)
                                    
                                    # Create .ssh directory and add key
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;mkdir&amp;quot;, &amp;quot;-p&amp;quot;, ssh_dir], check&#x3D;True)
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, f&amp;quot;echo &amp;#39;{ssh_public_key}&amp;#39; &amp;gt; {authorized_keys}&amp;quot;], check&#x3D;True)
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;chmod&amp;quot;, &amp;quot;700&amp;quot;, ssh_dir], check&#x3D;True)
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;chmod&amp;quot;, &amp;quot;600&amp;quot;, authorized_keys], check&#x3D;True)
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;chown&amp;quot;, &amp;quot;root:root&amp;quot;, ssh_dir], check&#x3D;True)
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;chown&amp;quot;, &amp;quot;root:root&amp;quot;, authorized_keys], check&#x3D;True)
                                    
                                    # Unmount
                                    subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;umount&amp;quot;, mount_point], check&#x3D;True)
                                    
                                    # Convert back to qcow2
                                    subprocess.run([
                                        &amp;quot;qemu-img&amp;quot;, &amp;quot;convert&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;raw&amp;quot;, &amp;quot;-O&amp;quot;, &amp;quot;qcow2&amp;quot;, raw_image, image_path
                                    ], check&#x3D;True)
                                    
                                    return {&amp;quot;success&amp;quot;: True, &amp;quot;method&amp;quot;: &amp;quot;loop_mount&amp;quot;}
                                
                            except (ValueError, subprocess.CalledProcessError) as e:
                                # Clean up mount if it exists
                                subprocess.run([&amp;quot;sudo&amp;quot;, &amp;quot;umount&amp;quot;, mount_point], capture_output&#x3D;True)
                                continue
                
                # If we get here, loop mount failed - fall back to a simpler approach
                return self._inject_ssh_key_cloud_init(image_path, ssh_public_key)
                
        except Exception as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Loop mount injection failed: {e}&amp;quot;}
    
    def _inject_ssh_key_cloud_init(self, image_path: str, ssh_public_key: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Fallback: Store SSH key info for runtime SSH use.&amp;quot;&amp;quot;&amp;quot;
        # Since image modification is complex, we&amp;#39;ll rely on the SSH client
        # using the stored keypair information for authentication
        print(f&amp;quot;💡 SSH key injection skipped - will use keypair directly for SSH authentication&amp;quot;)
        return {&amp;quot;success&amp;quot;: True, &amp;quot;method&amp;quot;: &amp;quot;runtime_auth&amp;quot;, &amp;quot;note&amp;quot;: &amp;quot;SSH will use stored keypair for authentication&amp;quot;}

    def _ensure_root_authorized_key(self, config: Dict[str, any]) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;Ensure the VM has the requested root SSH key configured via the agent account.&amp;quot;&amp;quot;&amp;quot;
        public_key &#x3D; config.get(&amp;quot;ssh_public_key&amp;quot;)
        if not public_key:
            return False

        if not shutil.which(&amp;quot;sshpass&amp;quot;):
            print(&amp;quot;⚠️  sshpass not available - skipping automatic SSH key provisioning&amp;quot;)
            return False

        ssh_port &#x3D; config[&amp;quot;ports&amp;quot;][&amp;quot;ssh&amp;quot;]
        escaped_key &#x3D; public_key.replace(&amp;quot;&amp;#39;&amp;quot;, &amp;quot;&amp;#39;\&amp;quot;&amp;#39;\&amp;quot;&amp;#39;&amp;quot;)
        remote_cmd &#x3D; (
            &amp;quot;sudo mkdir -p /root/.ssh &amp;amp;&amp;amp; &amp;quot;
            f&amp;quot;sudo sh -c \&amp;quot;grep -qxF &amp;#39;{escaped_key}&amp;#39; /root/.ssh/authorized_keys || echo &amp;#39;{escaped_key}&amp;#39; &amp;gt;&amp;gt; /root/.ssh/authorized_keys\&amp;quot; &amp;amp;&amp;amp; &amp;quot;
            &amp;quot;sudo chmod 700 /root/.ssh &amp;amp;&amp;amp; sudo chmod 600 /root/.ssh/authorized_keys&amp;quot;
        )

        ssh_cmd &#x3D; [
            &amp;quot;sshpass&amp;quot;, &amp;quot;-p&amp;quot;, &amp;quot;agent&amp;quot;,
            &amp;quot;ssh&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;UserKnownHostsFile&#x3D;/dev/null&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;ConnectTimeout&#x3D;10&amp;quot;,
            &amp;quot;-p&amp;quot;, str(ssh_port),
            &amp;quot;agent@localhost&amp;quot;,
            remote_cmd
        ]

        for attempt in range(12):
            result &#x3D; subprocess.run(ssh_cmd, capture_output&#x3D;True, text&#x3D;True)
            if result.returncode &#x3D;&#x3D; 0:
                return True
            time.sleep(5)

        print(&amp;quot;⚠️  Unable to inject SSH key automatically; password login may be required&amp;quot;)
        return False

    def create_vm(
        self,
        company_name: str,
        keypair_path: str,
        age_key_path: Optional[Path] &#x3D; None,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Create a new company VM.&amp;quot;&amp;quot;&amp;quot;
        if self._load_vm_config(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; already exists&amp;quot;}

        if age_key_path is not None:
            age_key_path &#x3D; Path(age_key_path).expanduser()

        warnings: List[str] &#x3D; []

        keypair_path &#x3D; Path(keypair_path).expanduser()
        public_key_path &#x3D; keypair_path.with_suffix(&amp;quot;.pub&amp;quot;)

        if not keypair_path.exists():
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Private key not found: {keypair_path}&amp;quot;}
        if not public_key_path.exists():
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Public key not found: {public_key_path}&amp;quot;}

        try:
            ssh_public_key &#x3D; public_key_path.read_text().strip()
        except Exception as exc:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to read public key: {exc}&amp;quot;}

        build_result &#x3D; self._build_vm_image(company_name, ssh_public_key)
        if not build_result[&amp;quot;success&amp;quot;]:
            print(f&amp;quot;⚠️  Build failed: {build_result[&amp;#39;error&amp;#39;]}&amp;quot;)
            print(&amp;quot;🔄 Will attempt to use existing working image...&amp;quot;)
            image_source: Optional[Path] &#x3D; None
        else:
            built_image &#x3D; build_result.get(&amp;quot;image&amp;quot;)
            image_source &#x3D; Path(built_image) if built_image else None
            if image_source and not image_source.exists():
                print(&amp;quot;⚠️  Built image path not found; falling back to cached image&amp;quot;)
                image_source &#x3D; None

        http_port, https_port, ssh_port, test_port &#x3D; self._get_next_port_range()

        config: Dict[str, any] &#x3D; {
            &amp;quot;name&amp;quot;: company_name,
            &amp;quot;keypair&amp;quot;: str(keypair_path),
            &amp;quot;ssh_public_key&amp;quot;: ssh_public_key,
            &amp;quot;ports&amp;quot;: {
                &amp;quot;http&amp;quot;: http_port,
                &amp;quot;https&amp;quot;: https_port,
                &amp;quot;ssh&amp;quot;: ssh_port,
                &amp;quot;test&amp;quot;: test_port,
            },
            &amp;quot;status&amp;quot;: &amp;quot;stopped&amp;quot;,
            &amp;quot;created_at&amp;quot;: time.time(),
            &amp;quot;image_path&amp;quot;: f&amp;quot;/home/nathan/Projects/rave/{company_name}-dev.qcow2&amp;quot;,
        }

        try:
            repo_root &#x3D; Path.cwd()
            if image_source and image_source.exists():
                shutil.copy2(image_source, config[&amp;quot;image_path&amp;quot;])
            elif (repo_root / &amp;quot;rave-complete-localhost.qcow2&amp;quot;).exists():
                print(f&amp;quot;Using existing working image for {company_name}&amp;quot;)
                shutil.copy2(
                    repo_root / &amp;quot;rave-complete-localhost.qcow2&amp;quot;, config[&amp;quot;image_path&amp;quot;]
                )
            else:
                return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;No VM image available&amp;quot;}

            Path(config[&amp;quot;image_path&amp;quot;]).chmod(0o644)

            injection_result &#x3D; self._inject_ssh_key(
                config[&amp;quot;image_path&amp;quot;], ssh_public_key
            )
            if not injection_result[&amp;quot;success&amp;quot;]:
                print(
                    f&amp;quot;⚠️  SSH key injection failed: {injection_result.get(&amp;#39;error&amp;#39;, &amp;#39;Unknown error&amp;#39;)}&amp;quot;
                )
                print(&amp;quot;🔄 VM will be created but may require password authentication&amp;quot;)

            if age_key_path:
                secrets_meta: Dict[str, any] &#x3D; {
                    &amp;quot;age_key_path&amp;quot;: str(age_key_path),
                }
                age_result &#x3D; self._install_age_key_into_image(
                    config[&amp;quot;image_path&amp;quot;],
                    age_key_path,
                )
                if age_result.get(&amp;quot;success&amp;quot;):
                    secrets_meta[&amp;quot;age_key_installed&amp;quot;] &#x3D; True
                else:
                    secrets_meta[&amp;quot;age_key_installed&amp;quot;] &#x3D; False
                    warnings.append(
                        age_result.get(
                            &amp;quot;error&amp;quot;,
                            &amp;quot;Failed to embed Age key; run &amp;#39;rave secrets install&amp;#39; before first boot&amp;quot;,
                        )
                    )
                config[&amp;quot;secrets&amp;quot;] &#x3D; secrets_meta

        except subprocess.CalledProcessError as exc:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to copy VM image: {exc}&amp;quot;}

        self._save_vm_config(company_name, config)

        response: Dict[str, any] &#x3D; {&amp;quot;success&amp;quot;: True, &amp;quot;config&amp;quot;: config}
        if warnings:
            response[&amp;quot;warnings&amp;quot;] &#x3D; warnings
        return response
    
    def start_vm(self, company_name: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Start a company VM.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        if self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is already running&amp;quot;}
        
        # Start VM with platform-specific launcher
        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        port_forwards &#x3D; [
            (ports[&amp;#39;http&amp;#39;], 80),
            (ports[&amp;#39;https&amp;#39;], 443),
            (ports[&amp;#39;ssh&amp;#39;], 22),
            (ports[&amp;#39;test&amp;#39;], 8080)
        ]

        # Ensure legacy external ports remain available for tooling that expects them.
        required_legacy_ports &#x3D; {
            18221: 443,
        }
        optional_legacy_ports &#x3D; {
            18220: 80,
            18231: 443,
            18230: 80,
        }
        existing_host_ports &#x3D; {host for host, _ in port_forwards}

        for host_port, guest_port in required_legacy_ports.items():
            if host_port in existing_host_ports:
                continue

            if not self._host_port_available(host_port):
                return {
                    &amp;quot;success&amp;quot;: False,
                    &amp;quot;error&amp;quot;: (
                        f&amp;quot;Host port {host_port} is already in use; &amp;quot;
                        &amp;quot;stop the conflicting process to expose GitLab/Mattermost on the documented port.&amp;quot;
                    ),
                }

            port_forwards.append((host_port, guest_port))
            existing_host_ports.add(host_port)

        for host_port, guest_port in optional_legacy_ports.items():
            if host_port in existing_host_ports:
                continue

            if not self._host_port_available(host_port):
                continue

            port_forwards.append((host_port, guest_port))
            existing_host_ports.add(host_port)
        memory_gb &#x3D; 4
        cmd, env &#x3D; self.platform.get_vm_start_command(
            config[&amp;#39;image_path&amp;#39;], 
            memory_gb&#x3D;memory_gb,
            port_forwards&#x3D;port_forwards
        )

        pidfile &#x3D; self.platform.get_temp_dir() / f&amp;quot;rave-{company_name}.pid&amp;quot;
        cmd.extend([
            &amp;quot;-daemonize&amp;quot;,
            &amp;quot;-pidfile&amp;quot;, str(pidfile)
        ])

        if env is not None and cmd:
            launcher &#x3D; Path(cmd[0])
            if launcher.name.startswith(&amp;quot;run-&amp;quot;):
                # Force headless mode and desired memory when using the Nix launcher script
                cmd.extend([
                    &amp;quot;-display&amp;quot;, &amp;quot;none&amp;quot;,
                    &amp;quot;-m&amp;quot;, f&amp;quot;{memory_gb}G&amp;quot;
                ])
        
        try:
            subprocess.run(cmd, check&#x3D;True, env&#x3D;env)
            
            # Update status
            config[&amp;quot;status&amp;quot;] &#x3D; &amp;quot;running&amp;quot;
            config[&amp;quot;started_at&amp;quot;] &#x3D; time.time()
            
            # Wait a moment for VM to initialize
            time.sleep(5)
            if self._ensure_root_authorized_key(config):
                config[&amp;quot;ssh_key_configured&amp;quot;] &#x3D; True
            
            self._save_vm_config(company_name, config)
            
            return {&amp;quot;success&amp;quot;: True}
        except subprocess.CalledProcessError as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to start VM: {e}&amp;quot;}
    
    def stop_vm(self, company_name: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Stop a company VM.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        # Kill VM process
        pidfile &#x3D; f&amp;quot;/tmp/rave-{company_name}.pid&amp;quot;
        try:
            if Path(pidfile).exists():
                with open(pidfile, &amp;#39;r&amp;#39;) as f:
                    pid &#x3D; f.read().strip()
                subprocess.run([&amp;quot;kill&amp;quot;, pid], check&#x3D;True)
                Path(pidfile).unlink()
        except (subprocess.CalledProcessError, FileNotFoundError):
            # Try alternative method
            subprocess.run([&amp;quot;pkill&amp;quot;, &amp;quot;-f&amp;quot;, f&amp;quot;rave-{company_name}&amp;quot;], check&#x3D;False)
        
        # Update status
        config[&amp;quot;status&amp;quot;] &#x3D; &amp;quot;stopped&amp;quot;
        if &amp;quot;started_at&amp;quot; in config:
            del config[&amp;quot;started_at&amp;quot;]
        self._save_vm_config(company_name, config)
        
        return {&amp;quot;success&amp;quot;: True}
    
    def _is_vm_running(self, company_name: str) -&amp;gt; bool:
        &amp;quot;&amp;quot;&amp;quot;Check if VM is running.&amp;quot;&amp;quot;&amp;quot;
        pidfile &#x3D; f&amp;quot;/tmp/rave-{company_name}.pid&amp;quot;
        if not Path(pidfile).exists():
            return False
        
        try:
            with open(pidfile, &amp;#39;r&amp;#39;) as f:
                pid &#x3D; f.read().strip()
            # Check if process exists
            subprocess.run([&amp;quot;kill&amp;quot;, &amp;quot;-0&amp;quot;, pid], check&#x3D;True, capture_output&#x3D;True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False
    
    def status_vm(self, company_name: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get VM status.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        running &#x3D; self._is_vm_running(company_name)
        status &#x3D; &amp;quot;running&amp;quot; if running else &amp;quot;stopped&amp;quot;
        
        return {
            &amp;quot;success&amp;quot;: True,
            &amp;quot;running&amp;quot;: running,
            &amp;quot;status&amp;quot;: status,
            &amp;quot;config&amp;quot;: config
        }
    
    def status_all_vms(self) -&amp;gt; Dict[str, Dict]:
        &amp;quot;&amp;quot;&amp;quot;Get status of all VMs.&amp;quot;&amp;quot;&amp;quot;
        results &#x3D; {}
        for config_file in self.vms_dir.glob(&amp;quot;*.json&amp;quot;):
            company_name &#x3D; config_file.stem
            status_result &#x3D; self.status_vm(company_name)
            if status_result[&amp;quot;success&amp;quot;]:
                results[company_name] &#x3D; {
                    &amp;quot;running&amp;quot;: status_result[&amp;quot;running&amp;quot;],
                    &amp;quot;status&amp;quot;: status_result[&amp;quot;status&amp;quot;]
                }
        return results
    
    def reset_vm(self, company_name: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Reset VM to default state.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        # Stop VM if running
        if self._is_vm_running(company_name):
            stop_result &#x3D; self.stop_vm(company_name)
            if not stop_result[&amp;quot;success&amp;quot;]:
                return stop_result
        
        # Rebuild and copy fresh VM image
        build_result &#x3D; self._build_vm_image()
        if not build_result[&amp;quot;success&amp;quot;]:
            return build_result

        create_result &#x3D; self._create_blank_disk(Path(config[&amp;quot;image_path&amp;quot;]))
        if not create_result.get(&amp;quot;success&amp;quot;):
            return create_result

        ssh_public_key &#x3D; config.get(&amp;quot;ssh_public_key&amp;quot;)
        if ssh_public_key:
            injection_result &#x3D; self._inject_ssh_key(
                config[&amp;quot;image_path&amp;quot;], ssh_public_key
            )
            if not injection_result.get(&amp;quot;success&amp;quot;):
                return {
                    &amp;quot;success&amp;quot;: True,
                    &amp;quot;warning&amp;quot;: injection_result.get(
                        &amp;quot;error&amp;quot;, &amp;quot;Unable to reinject SSH key&amp;quot;
                    ),
                }

        return {&amp;quot;success&amp;quot;: True}
    
    def ssh_vm(self, company_name: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;SSH into company VM.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}
        
        # SSH with keypair (if available) or password fallback
        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        keypair_path &#x3D; config.get(&amp;quot;keypair&amp;quot;)
        
        # Try SSH with multiple authentication methods
        if keypair_path and Path(keypair_path).exists():
            # First try key-based authentication
            ssh_cmd &#x3D; [
                &amp;quot;ssh&amp;quot;,
                &amp;quot;-i&amp;quot;, keypair_path,
                &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
                &amp;quot;-o&amp;quot;, &amp;quot;PasswordAuthentication&#x3D;no&amp;quot;,
                &amp;quot;-o&amp;quot;, &amp;quot;ConnectTimeout&#x3D;10&amp;quot;,
                &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]),
                &amp;quot;root@localhost&amp;quot;
            ]
            
            # Test SSH connection first
            test_result &#x3D; subprocess.run(ssh_cmd + [&amp;quot;echo&amp;quot;, &amp;quot;SSH key test&amp;quot;], 
                                       capture_output&#x3D;True, text&#x3D;True, timeout&#x3D;15)
            
            if test_result.returncode &#x3D;&#x3D; 0:
                print(&amp;quot;🔑 SSH key authentication successful!&amp;quot;)
                # Use key-based auth
                import os
                os.execvp(&amp;quot;ssh&amp;quot;, ssh_cmd)
            else:
                print(&amp;quot;🔑 SSH key failed, trying password authentication...&amp;quot;)
                
        # Fallback to password authentication
        ssh_cmd &#x3D; [
            &amp;quot;sshpass&amp;quot;, &amp;quot;-p&amp;quot;, &amp;quot;debug123&amp;quot;,
            &amp;quot;ssh&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;ConnectTimeout&#x3D;10&amp;quot;,
            &amp;quot;-o&amp;quot;, &amp;quot;PreferredAuthentications&#x3D;password&amp;quot;,
            &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]),
            &amp;quot;root@localhost&amp;quot;
        ]
        
        # Test password authentication
        test_result &#x3D; subprocess.run(ssh_cmd + [&amp;quot;echo&amp;quot;, &amp;quot;SSH password test&amp;quot;], 
                                   capture_output&#x3D;True, text&#x3D;True, timeout&#x3D;15)
        
        if test_result.returncode &#x3D;&#x3D; 0:
            print(&amp;quot;🔐 SSH password authentication successful!&amp;quot;)
            # Use password auth
            import os
            os.execvp(&amp;quot;sshpass&amp;quot;, ssh_cmd)
        else:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;SSH connection failed with both key and password: {test_result.stderr}&amp;quot;}
    
    def get_logs(self, company_name: str, service: Optional[str] &#x3D; None, 
                 follow: bool &#x3D; False, tail: int &#x3D; 50, since: Optional[str] &#x3D; None,
                 all_services: bool &#x3D; False) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get VM service logs.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}
        
        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}
        
        # Build SSH command for journalctl
        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        keypair_path &#x3D; config.get(&amp;quot;keypair&amp;quot;)
        
        if keypair_path and Path(keypair_path).exists():
            ssh_base &#x3D; [
                &amp;quot;ssh&amp;quot;, &amp;quot;-i&amp;quot;, keypair_path, &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
                &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]), &amp;quot;root@localhost&amp;quot;
            ]
            program &#x3D; &amp;quot;ssh&amp;quot;
        else:
            ssh_base &#x3D; [
                &amp;quot;sshpass&amp;quot;, &amp;quot;-p&amp;quot;, &amp;quot;debug123&amp;quot;,
                &amp;quot;ssh&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
                &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]), &amp;quot;root@localhost&amp;quot;
            ]
            program &#x3D; &amp;quot;sshpass&amp;quot;
        
        # Build journalctl command
        journalctl_cmd &#x3D; [&amp;quot;journalctl&amp;quot;]
        
        if service and not all_services:
            journalctl_cmd.extend([&amp;quot;-u&amp;quot;, f&amp;quot;{service}.service&amp;quot;])
        elif all_services:
            # Show logs from all main services
            services &#x3D; [&amp;quot;nginx&amp;quot;, &amp;quot;postgresql&amp;quot;, &amp;quot;nats&amp;quot;, &amp;quot;redis-default&amp;quot;, &amp;quot;redis-gitlab&amp;quot;]
            for svc in services:
                journalctl_cmd.extend([&amp;quot;-u&amp;quot;, f&amp;quot;{svc}.service&amp;quot;])
        
        if follow:
            journalctl_cmd.append(&amp;quot;-f&amp;quot;)
        else:
            journalctl_cmd.extend([&amp;quot;-n&amp;quot;, str(tail)])
        
        if since:
            journalctl_cmd.extend([&amp;quot;--since&amp;quot;, since])
        
        journalctl_cmd.append(&amp;quot;--no-pager&amp;quot;)
        
        full_cmd &#x3D; ssh_base + journalctl_cmd
        
        try:
            # Execute and stream output
            import os
            os.execvp(program, full_cmd)
        except Exception as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to get logs: {e}&amp;quot;}

    def install_age_key(self, company_name: str, key_file: Path,
                         remote_path: str &#x3D; &amp;quot;/var/lib/sops-nix/key.txt&amp;quot;) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Install an Age key into a running VM for sops-nix.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}

        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}

        key_path &#x3D; Path(key_file).expanduser()
        if not key_path.exists():
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Age key file not found: {key_path}&amp;quot;}

        key_text &#x3D; key_path.read_text().strip()
        if not key_text:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Age key file is empty&amp;quot;}

        # Prepare remote script to install the key with correct permissions
        remote_file &#x3D; Path(remote_path)
        remote_dir &#x3D; remote_file.parent

        dir_q &#x3D; shlex.quote(str(remote_dir))
        file_q &#x3D; shlex.quote(str(remote_file))

        remote_script &#x3D; (
            &amp;quot;set -euo pipefail\n&amp;quot;
            f&amp;quot;install -d -m 700 -o root -g root {dir_q}\n&amp;quot;
            f&amp;quot;cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; {file_q}\n&amp;quot;
            f&amp;quot;{key_text}\n&amp;quot;
            &amp;quot;EOF\n&amp;quot;
            f&amp;quot;chmod 600 {file_q}\n&amp;quot;
            f&amp;quot;chown root:root {file_q}\n&amp;quot;
        )

        run_result &#x3D; self._run_remote_script(
            config,
            remote_script,
            timeout&#x3D;240,
            description&#x3D;&amp;quot;installing Age key&amp;quot;,
            max_attempts&#x3D;8,
            initial_delay&#x3D;1.5,
        )

        if not run_result.get(&amp;quot;success&amp;quot;):
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: run_result.get(&amp;quot;error&amp;quot;, &amp;quot;Failed to install Age key&amp;quot;),
            }

        return {&amp;quot;success&amp;quot;: True, &amp;quot;path&amp;quot;: remote_path}

    def install_secret_files(
        self,
        company_name: str,
        entries: List[Dict[str, str]],
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Install one or more secrets on the VM using a single SSH session.&amp;quot;&amp;quot;&amp;quot;
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}

        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}

        secrets &#x3D; [entry for entry in entries if entry.get(&amp;quot;content&amp;quot;)]
        if not secrets:
            return {&amp;quot;success&amp;quot;: True}

        remote_lines &#x3D; [&amp;quot;set -euo pipefail&amp;quot;]

        for secret in secrets:
            remote_path &#x3D; secret[&amp;quot;remote_path&amp;quot;]
            content &#x3D; secret[&amp;quot;content&amp;quot;]
            owner &#x3D; secret.get(&amp;quot;owner&amp;quot;, &amp;quot;root&amp;quot;)
            group &#x3D; secret.get(&amp;quot;group&amp;quot;, owner)
            mode &#x3D; secret.get(&amp;quot;mode&amp;quot;, &amp;quot;0600&amp;quot;)
            dir_mode &#x3D; secret.get(&amp;quot;dir_mode&amp;quot;, &amp;quot;0700&amp;quot;)

            remote_file &#x3D; Path(remote_path)
            remote_dir &#x3D; remote_file.parent

            dir_q &#x3D; shlex.quote(str(remote_dir))
            file_q &#x3D; shlex.quote(str(remote_file))
            encoded &#x3D; base64.b64encode(content.encode()).decode()

            remote_lines.extend(
                [
                    f&amp;quot;install -d -m {dir_mode} -o {owner} -g {group} {dir_q}&amp;quot;,
                    f&amp;quot;base64 -d &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; &amp;gt; {file_q}&amp;quot;,
                    encoded,
                    &amp;quot;EOF&amp;quot;,
                    f&amp;quot;chmod {mode} {file_q}&amp;quot;,
                    f&amp;quot;chown {owner}:{group} {file_q}&amp;quot;,
                ]
            )

        remote_script &#x3D; &amp;quot;\n&amp;quot;.join(remote_lines) + &amp;quot;\n&amp;quot;

        run_result &#x3D; self._run_remote_script(
            config,
            remote_script,
            timeout&#x3D;600,
            description&#x3D;&amp;quot;installing secret files&amp;quot;,
        )

        if not run_result.get(&amp;quot;success&amp;quot;):
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: run_result.get(&amp;quot;error&amp;quot;, &amp;quot;unknown error installing secret&amp;quot;),
            }

        return {&amp;quot;success&amp;quot;: True}

    def install_secret_file(
        self,
        company_name: str,
        remote_path: str,
        content: str,
        owner: str,
        group: str,
        mode: str,
        dir_mode: str &#x3D; &amp;quot;0700&amp;quot;,
    ) -&amp;gt; Dict[str, any]:
        entry &#x3D; {
            &amp;quot;remote_path&amp;quot;: remote_path,
            &amp;quot;content&amp;quot;: content,
            &amp;quot;owner&amp;quot;: owner,
            &amp;quot;group&amp;quot;: group,
            &amp;quot;mode&amp;quot;: mode,
            &amp;quot;dir_mode&amp;quot;: dir_mode,
        }
        return self.install_secret_files(company_name, [entry])

    def ensure_mattermost_database(self, company_name: str, password: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Ensure the Mattermost database role and password are configured.&amp;quot;&amp;quot;&amp;quot;

        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}

        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}

        password_sql &#x3D; password.replace(&amp;quot;&amp;#39;&amp;quot;, &amp;quot;&amp;#39;&amp;#39;&amp;quot;)
        remote_script &#x3D; &amp;quot;\n&amp;quot;.join(
            [
                &amp;quot;set -euo pipefail&amp;quot;,
                &amp;quot;sudo -u postgres psql postgres &amp;lt;&amp;lt;&amp;#39;SQL&amp;#39;&amp;quot;,
                &amp;quot;DO $$&amp;quot;,
                &amp;quot;BEGIN&amp;quot;,
                &amp;quot;  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname &#x3D; &amp;#39;mattermost&amp;#39;) THEN&amp;quot;,
                f&amp;quot;    CREATE ROLE mattermost WITH LOGIN PASSWORD &amp;#39;{password_sql}&amp;#39;;&amp;quot;,
                &amp;quot;  ELSE&amp;quot;,
                f&amp;quot;    ALTER ROLE mattermost WITH LOGIN PASSWORD &amp;#39;{password_sql}&amp;#39;;&amp;quot;,
                &amp;quot;  END IF;&amp;quot;,
                &amp;quot;END&amp;quot;,
                &amp;quot;$$;&amp;quot;,
                &amp;quot;SQL&amp;quot;,
                &amp;quot;sudo -u postgres psql postgres -tc \&amp;quot;SELECT 1 FROM pg_database WHERE datname &#x3D; &amp;#39;mattermost&amp;#39;;\&amp;quot; | grep -q 1 || sudo -u postgres createdb -O mattermost mattermost&amp;quot;,
                &amp;quot;sudo -u postgres psql mattermost -c \&amp;quot;GRANT ALL PRIVILEGES ON SCHEMA public TO mattermost;\&amp;quot;&amp;quot;,
            ]
        ) + &amp;quot;\n&amp;quot;

        run_result &#x3D; self._run_remote_script(
            config,
            remote_script,
            timeout&#x3D;180,
            description&#x3D;&amp;quot;resetting Mattermost database&amp;quot;,
        )

        if not run_result.get(&amp;quot;success&amp;quot;):
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: run_result.get(&amp;quot;error&amp;quot;, &amp;quot;database command failed&amp;quot;),
            }

        return {&amp;quot;success&amp;quot;: True}

    def ensure_gitlab_database_password(self, company_name: str, password: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Ensure the GitLab database user password matches the injected secret.&amp;quot;&amp;quot;&amp;quot;

        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; not found&amp;quot;}

        if not self._is_vm_running(company_name):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_name}&amp;#39; is not running&amp;quot;}

        password_sql &#x3D; password.replace(&amp;quot;&amp;#39;&amp;quot;, &amp;quot;&amp;#39;&amp;#39;&amp;quot;)
        remote_script &#x3D; &amp;quot;\n&amp;quot;.join(
            [
                &amp;quot;set -euo pipefail&amp;quot;,
                &amp;quot;sudo -u postgres psql postgres &amp;lt;&amp;lt;&amp;#39;SQL&amp;#39;&amp;quot;,
                f&amp;quot;ALTER ROLE gitlab WITH LOGIN PASSWORD &amp;#39;{password_sql}&amp;#39;;&amp;quot;,
                &amp;quot;SQL&amp;quot;,
            ]
        ) + &amp;quot;\n&amp;quot;

        run_result &#x3D; self._run_remote_script(
            config,
            remote_script,
            timeout&#x3D;60,
            description&#x3D;&amp;quot;refreshing GitLab database password&amp;quot;,
        )

        if not run_result.get(&amp;quot;success&amp;quot;):
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: run_result.get(&amp;quot;error&amp;quot;, &amp;quot;database command failed&amp;quot;),
            }

        return {&amp;quot;success&amp;quot;: True}

    # TLS helpers ---------------------------------------------------------

    def install_tls_certificate(
        self,
        company_name: str,
        *,
        cert_pem: str,
        fullchain_pem: str,
        key_pem: str,
        ca_pem: str,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Copy TLS materials into the VM and restart nginx.&amp;quot;&amp;quot;&amp;quot;

        entries &#x3D; [
            {
                &amp;quot;remote_path&amp;quot;: &amp;quot;/var/lib/acme/localhost/cert.pem&amp;quot;,
                &amp;quot;content&amp;quot;: fullchain_pem,
                &amp;quot;owner&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;group&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;mode&amp;quot;: &amp;quot;0644&amp;quot;,
                &amp;quot;dir_mode&amp;quot;: &amp;quot;0755&amp;quot;,
            },
            {
                &amp;quot;remote_path&amp;quot;: &amp;quot;/var/lib/acme/localhost/fullchain.pem&amp;quot;,
                &amp;quot;content&amp;quot;: fullchain_pem,
                &amp;quot;owner&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;group&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;mode&amp;quot;: &amp;quot;0644&amp;quot;,
                &amp;quot;dir_mode&amp;quot;: &amp;quot;0755&amp;quot;,
            },
            {
                &amp;quot;remote_path&amp;quot;: &amp;quot;/var/lib/acme/localhost/chain.pem&amp;quot;,
                &amp;quot;content&amp;quot;: ca_pem,
                &amp;quot;owner&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;group&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;mode&amp;quot;: &amp;quot;0644&amp;quot;,
                &amp;quot;dir_mode&amp;quot;: &amp;quot;0755&amp;quot;,
            },
            {
                &amp;quot;remote_path&amp;quot;: &amp;quot;/var/lib/acme/localhost/key.pem&amp;quot;,
                &amp;quot;content&amp;quot;: key_pem,
                &amp;quot;owner&amp;quot;: &amp;quot;root&amp;quot;,
                &amp;quot;group&amp;quot;: &amp;quot;nginx&amp;quot;,
                &amp;quot;mode&amp;quot;: &amp;quot;0640&amp;quot;,
                &amp;quot;dir_mode&amp;quot;: &amp;quot;0750&amp;quot;,
            },
        ]

        return self.install_secret_files(company_name, entries)

    def record_tls_metadata(self, company_name: str, metadata: Dict[str, any]) -&amp;gt; bool:
        config &#x3D; self._load_vm_config(company_name)
        if not config:
            return False

        tls_meta &#x3D; config.get(&amp;quot;tls&amp;quot;, {})
        tls_meta.update(metadata)
        tls_meta[&amp;quot;updated_at&amp;quot;] &#x3D; time.time()
        config[&amp;quot;tls&amp;quot;] &#x3D; tls_meta
        self._save_vm_config(company_name, config)
        return True
</pre>
                </div>
            </div>
            <div class="file-section" id="file-3">
                <div class="file-header">📄 platform_utils.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;
Platform-specific utilities for RAVE CLI
Handles differences between macOS, Linux, and potentially Windows
&amp;quot;&amp;quot;&amp;quot;
import os
import platform
import shutil
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple

class PlatformManager:
    def __init__(self):
        self.system &#x3D; platform.system()
        self.machine &#x3D; platform.machine()
        
    def is_macos(self) -&amp;gt; bool:
        return self.system &#x3D;&#x3D; &amp;quot;Darwin&amp;quot;
    
    def is_linux(self) -&amp;gt; bool:
        return self.system &#x3D;&#x3D; &amp;quot;Linux&amp;quot;
        
    def is_apple_silicon(self) -&amp;gt; bool:
        return self.is_macos() and self.machine in (&amp;quot;arm64&amp;quot;, &amp;quot;aarch64&amp;quot;)
        
    def get_qemu_binary(self) -&amp;gt; Optional[str]:
        &amp;quot;&amp;quot;&amp;quot;Get the appropriate QEMU binary for this platform.&amp;quot;&amp;quot;&amp;quot;
        if self.is_apple_silicon():
            # Apple Silicon needs emulation for x86_64 VMs
            return shutil.which(&amp;quot;qemu-system-x86_64&amp;quot;)
        elif self.is_macos():
            # Intel Mac
            return shutil.which(&amp;quot;qemu-system-x86_64&amp;quot;)
        else:
            # Linux
            return shutil.which(&amp;quot;qemu-system-x86_64&amp;quot;)
    
    def get_acceleration_flags(self) -&amp;gt; List[str]:
        &amp;quot;&amp;quot;&amp;quot;Get hardware acceleration flags for QEMU.&amp;quot;&amp;quot;&amp;quot;
        if self.is_macos():
            return [&amp;quot;-accel&amp;quot;, &amp;quot;hvf&amp;quot;]  # Hypervisor Framework on macOS
        elif self.is_linux():
            if Path(&amp;quot;/dev/kvm&amp;quot;).exists():
                return [&amp;quot;-accel&amp;quot;, &amp;quot;kvm&amp;quot;]  # KVM on Linux
            else:
                return []  # No acceleration available
        else:
            return []  # Windows or other
    
    def get_nix_build_command(self) -&amp;gt; List[str]:
        &amp;quot;&amp;quot;&amp;quot;Get Nix build command with platform-specific flags.&amp;quot;&amp;quot;&amp;quot;
        base_cmd &#x3D; [&amp;quot;nix&amp;quot;, &amp;quot;build&amp;quot;]
        
        if self.is_apple_silicon():
            # Apple Silicon may need Rosetta 2 for x86_64 builds
            base_cmd.extend([&amp;quot;--system&amp;quot;, &amp;quot;x86_64-darwin&amp;quot;])
        
        return base_cmd
    
    def check_prerequisites(self) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Check if all required tools are available on this platform.&amp;quot;&amp;quot;&amp;quot;
        missing &#x3D; []
        warnings &#x3D; []
        
        # Check Nix
        if not shutil.which(&amp;quot;nix&amp;quot;):
            missing.append(&amp;quot;nix&amp;quot;)
        else:
            # Check if flakes are enabled
            try:
                result &#x3D; subprocess.run(
                    [&amp;quot;nix&amp;quot;, &amp;quot;flake&amp;quot;, &amp;quot;--help&amp;quot;], 
                    capture_output&#x3D;True, 
                    text&#x3D;True
                )
                if result.returncode !&#x3D; 0:
                    warnings.append(&amp;quot;Nix flakes not enabled - run: echo &amp;#39;experimental-features &#x3D; nix-command flakes&amp;#39; &amp;gt;&amp;gt; ~/.config/nix/nix.conf&amp;quot;)
            except:
                warnings.append(&amp;quot;Could not verify Nix flakes support&amp;quot;)
        
        # Check QEMU
        qemu_binary &#x3D; self.get_qemu_binary()
        if not qemu_binary:
            if self.is_macos():
                missing.append(&amp;quot;qemu (install with: brew install qemu)&amp;quot;)
            else:
                missing.append(&amp;quot;qemu-system-x86_64&amp;quot;)
        
        # Check secrets tooling
        if not shutil.which(&amp;quot;sops&amp;quot;):
            missing.append(&amp;quot;sops (https://github.com/getsops/sops/releases)&amp;quot;)

        age_present &#x3D; shutil.which(&amp;quot;age&amp;quot;) or shutil.which(&amp;quot;age-keygen&amp;quot;)
        if not age_present:
            missing.append(&amp;quot;age / age-keygen (https://github.com/FiloSottile/age/releases)&amp;quot;)

        # Check virtualization support
        if self.is_macos():
            # Check if HVF is available
            try:
                result &#x3D; subprocess.run(
                    [&amp;quot;sysctl&amp;quot;, &amp;quot;-n&amp;quot;, &amp;quot;kern.hv_support&amp;quot;],
                    capture_output&#x3D;True,
                    text&#x3D;True
                )
                if result.stdout.strip() !&#x3D; &amp;quot;1&amp;quot;:
                    warnings.append(&amp;quot;Hypervisor Framework not available - VM performance will be poor&amp;quot;)
            except:
                warnings.append(&amp;quot;Could not check Hypervisor Framework support&amp;quot;)
        elif self.is_linux():
            if not Path(&amp;quot;/dev/kvm&amp;quot;).exists():
                warnings.append(&amp;quot;KVM not available - VM performance will be poor&amp;quot;)
        
        # Apple Silicon specific checks
        if self.is_apple_silicon():
            warnings.append(&amp;quot;Apple Silicon detected - x86_64 VM will run under emulation (slower)&amp;quot;)
            
            # Check if Rosetta 2 is installed for Nix builds
            if not Path(&amp;quot;/Library/Apple/usr/share/rosetta&amp;quot;).exists():
                warnings.append(&amp;quot;Rosetta 2 not detected - install with: softwareupdate --install-rosetta&amp;quot;)
        
        return {
            &amp;quot;success&amp;quot;: len(missing) &#x3D;&#x3D; 0,
            &amp;quot;missing&amp;quot;: missing,
            &amp;quot;warnings&amp;quot;: warnings
        }

    # TLS / mkcert helpers -------------------------------------------------

    def ensure_mkcert_installed(self) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Ensure mkcert is available on the host, installing it if possible.&amp;quot;&amp;quot;&amp;quot;

        if shutil.which(&amp;quot;mkcert&amp;quot;):
            return {&amp;quot;success&amp;quot;: True, &amp;quot;installed&amp;quot;: False}

        install_steps: List[List[str]] &#x3D; []

        if self.is_macos() and shutil.which(&amp;quot;brew&amp;quot;):
            install_steps.append([&amp;quot;brew&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;mkcert&amp;quot;, &amp;quot;nss&amp;quot;])
        elif self.is_linux():
            if shutil.which(&amp;quot;apt-get&amp;quot;):
                install_steps.append([&amp;quot;sudo&amp;quot;, &amp;quot;apt-get&amp;quot;, &amp;quot;update&amp;quot;])
                install_steps.append([&amp;quot;sudo&amp;quot;, &amp;quot;apt-get&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;-y&amp;quot;, &amp;quot;mkcert&amp;quot;, &amp;quot;libnss3-tools&amp;quot;])
            elif shutil.which(&amp;quot;dnf&amp;quot;):
                install_steps.append([&amp;quot;sudo&amp;quot;, &amp;quot;dnf&amp;quot;, &amp;quot;install&amp;quot;, &amp;quot;-y&amp;quot;, &amp;quot;mkcert&amp;quot;, &amp;quot;nss-tools&amp;quot;])
            elif shutil.which(&amp;quot;pacman&amp;quot;):
                install_steps.append([&amp;quot;sudo&amp;quot;, &amp;quot;pacman&amp;quot;, &amp;quot;-Sy&amp;quot;, &amp;quot;mkcert&amp;quot;, &amp;quot;nss&amp;quot;])

        if not install_steps:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: &amp;quot;mkcert not found and automatic installation is unavailable&amp;quot;,
                &amp;quot;hint&amp;quot;: &amp;quot;Install mkcert manually (see https://github.com/FiloSottile/mkcert) and rerun.&amp;quot;
            }

        for step in install_steps:
            try:
                result &#x3D; subprocess.run(step, check&#x3D;True, capture_output&#x3D;True, text&#x3D;True)
            except subprocess.CalledProcessError as exc:
                stderr &#x3D; exc.stderr.strip() if exc.stderr else &amp;quot;unknown error&amp;quot;
                return {
                    &amp;quot;success&amp;quot;: False,
                    &amp;quot;error&amp;quot;: f&amp;quot;Failed to run &amp;#39;{&amp;#39; &amp;#39;.join(step)}&amp;#39;: {stderr}&amp;quot;
                }

        if shutil.which(&amp;quot;mkcert&amp;quot;):
            return {&amp;quot;success&amp;quot;: True, &amp;quot;installed&amp;quot;: True}

        return {
            &amp;quot;success&amp;quot;: False,
            &amp;quot;error&amp;quot;: &amp;quot;mkcert installation attempted but the binary is still missing.&amp;quot;
        }

    def mkcert_caroot(self) -&amp;gt; Optional[Path]:
        &amp;quot;&amp;quot;&amp;quot;Return the mkcert CA root directory if available.&amp;quot;&amp;quot;&amp;quot;

        if not shutil.which(&amp;quot;mkcert&amp;quot;):
            return None

        try:
            result &#x3D; subprocess.run(
                [&amp;quot;mkcert&amp;quot;, &amp;quot;-CAROOT&amp;quot;],
                check&#x3D;True,
                capture_output&#x3D;True,
                text&#x3D;True,
            )
        except subprocess.CalledProcessError:
            return None

        return Path(result.stdout.strip())
    
    def get_vm_start_command(self, image_path: str, memory_gb: int &#x3D; 4,
                             port_forwards: List[Tuple[int, int]] &#x3D; None) -&amp;gt; Tuple[List[str], Optional[Dict[str, str]]]:
        &amp;quot;&amp;quot;&amp;quot;Generate command and environment for starting a VM.&amp;quot;&amp;quot;&amp;quot;
        repo_root &#x3D; Path(__file__).resolve().parent.parent
        nix_vm_launcher &#x3D; repo_root / &amp;quot;result&amp;quot; / &amp;quot;bin&amp;quot; / &amp;quot;run-rave-complete-vm&amp;quot;

        if self.is_linux() and nix_vm_launcher.exists():
            env &#x3D; os.environ.copy()
            env[&amp;quot;NIX_DISK_IMAGE&amp;quot;] &#x3D; str(Path(image_path).resolve())

            if port_forwards:
                hostfwd_rules &#x3D; [
                    f&amp;quot;hostfwd&#x3D;tcp::{host_port}-:{guest_port}&amp;quot;
                    for host_port, guest_port in port_forwards
                ]
                env[&amp;quot;QEMU_NET_OPTS&amp;quot;] &#x3D; &amp;quot;,&amp;quot;.join(hostfwd_rules)

            return [str(nix_vm_launcher)], env

        qemu_binary &#x3D; self.get_qemu_binary()
        if not qemu_binary:
            raise RuntimeError(&amp;quot;QEMU not available&amp;quot;)

        cmd &#x3D; [qemu_binary]

        # Basic VM settings
        cmd.extend([
            &amp;quot;-drive&amp;quot;, f&amp;quot;file&#x3D;{image_path},format&#x3D;qcow2&amp;quot;,
            &amp;quot;-m&amp;quot;, f&amp;quot;{memory_gb}G&amp;quot;,
            &amp;quot;-smp&amp;quot;, &amp;quot;2&amp;quot;
        ])

        # Hardware acceleration
        cmd.extend(self.get_acceleration_flags())

        # Network with port forwarding
        if port_forwards:
            hostfwd_rules &#x3D; [
                f&amp;quot;hostfwd&#x3D;tcp::{host_port}-:{guest_port}&amp;quot;
                for host_port, guest_port in port_forwards
            ]

            netdev &#x3D; f&amp;quot;user,id&#x3D;net0,{&amp;#39;,&amp;#39;.join(hostfwd_rules)}&amp;quot;
            cmd.extend([
                &amp;quot;-netdev&amp;quot;, netdev,
                &amp;quot;-device&amp;quot;, &amp;quot;virtio-net-pci,netdev&#x3D;net0&amp;quot;
            ])
        else:
            cmd.extend([
                &amp;quot;-netdev&amp;quot;, &amp;quot;user,id&#x3D;net0&amp;quot;,
                &amp;quot;-device&amp;quot;, &amp;quot;virtio-net-pci,netdev&#x3D;net0&amp;quot;
            ])

        # Platform-specific optimizations
        if self.is_macos():
            # macOS-specific QEMU optimizations
            cmd.extend([
                &amp;quot;-display&amp;quot;, &amp;quot;none&amp;quot;,  # No GUI on macOS
                &amp;quot;-serial&amp;quot;, &amp;quot;mon:stdio&amp;quot;  # Serial console for debugging
            ])
        else:
            # Linux-specific optimizations
            cmd.extend([
                &amp;quot;-display&amp;quot;, &amp;quot;none&amp;quot;
            ])

        return cmd, None
    
    def get_temp_dir(self) -&amp;gt; Path:
        &amp;quot;&amp;quot;&amp;quot;Get platform-appropriate temporary directory.&amp;quot;&amp;quot;&amp;quot;
        if self.is_macos():
            return Path(&amp;quot;/tmp&amp;quot;)
        else:
            return Path(&amp;quot;/tmp&amp;quot;)
    
    def get_config_dir(self) -&amp;gt; Path:
        &amp;quot;&amp;quot;&amp;quot;Get platform-appropriate configuration directory.&amp;quot;&amp;quot;&amp;quot;
        if self.is_macos():
            return Path.home() / &amp;quot;Library&amp;quot; / &amp;quot;Application Support&amp;quot; / &amp;quot;rave&amp;quot;
        else:
            return Path.home() / &amp;quot;.config&amp;quot; / &amp;quot;rave&amp;quot;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-4">
                <div class="file-header">📄 user_manager.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;User Manager - Handles GitLab OAuth user management within VMs.&amp;quot;&amp;quot;&amp;quot;

import copy
import json
import re
import subprocess
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from vm_manager import VMManager


class UserManager:
    &amp;quot;&amp;quot;&amp;quot;Manages users via GitLab OAuth integration.&amp;quot;&amp;quot;&amp;quot;
    
    def __init__(self):
        self.config_dir &#x3D; Path.home() / &amp;quot;.config&amp;quot; / &amp;quot;rave&amp;quot;
        self.users_file &#x3D; self.config_dir / &amp;quot;users.json&amp;quot;
        self.config_dir.mkdir(parents&#x3D;True, exist_ok&#x3D;True)
        self.supported_providers &#x3D; {&amp;quot;google_oauth2&amp;quot;, &amp;quot;github&amp;quot;}
        self.default_provider &#x3D; &amp;quot;google_oauth2&amp;quot;

    def set_default_provider(self, provider: str):
        &amp;quot;&amp;quot;&amp;quot;Set the default OAuth provider used when none is provided.&amp;quot;&amp;quot;&amp;quot;
        self.default_provider &#x3D; self._normalize_provider(provider)
    
    def _load_users(self) -&amp;gt; Dict:
        &amp;quot;&amp;quot;&amp;quot;Load users configuration.&amp;quot;&amp;quot;&amp;quot;
        if not self.users_file.exists():
            return {&amp;quot;users&amp;quot;: []}
        try:
            return json.loads(self.users_file.read_text())
        except (json.JSONDecodeError, FileNotFoundError):
            return {&amp;quot;users&amp;quot;: []}
    
    def _save_users(self, users_data: Dict):
        &amp;quot;&amp;quot;&amp;quot;Save users configuration.&amp;quot;&amp;quot;&amp;quot;
        self.users_file.write_text(json.dumps(users_data, indent&#x3D;2))
    
    def _find_user(self, users_data: Dict, email: str) -&amp;gt; Optional[Dict]:
        &amp;quot;&amp;quot;&amp;quot;Find user by email.&amp;quot;&amp;quot;&amp;quot;
        for user in users_data[&amp;quot;users&amp;quot;]:
            if user[&amp;quot;email&amp;quot;] &#x3D;&#x3D; email:
                return user
        return None

    def _normalize_provider(self, provider: Optional[str]) -&amp;gt; str:
        if not provider:
            return self.default_provider

        value &#x3D; provider.strip()
        if not value:
            return self.default_provider

        key &#x3D; value.lower()
        if key in {&amp;quot;google&amp;quot;, &amp;quot;google_oauth2&amp;quot;}:
            return &amp;quot;google_oauth2&amp;quot;
        if key &#x3D;&#x3D; &amp;quot;github&amp;quot;:
            return &amp;quot;github&amp;quot;
        if key in self.supported_providers:
            return key
        raise ValueError(f&amp;quot;Unsupported OAuth provider: {provider}&amp;quot;)

    def _provider_label(self, provider: Optional[str]) -&amp;gt; str:
        normalized &#x3D; self._normalize_provider(provider)
        if normalized &#x3D;&#x3D; &amp;quot;google_oauth2&amp;quot;:
            return &amp;quot;Google&amp;quot;
        if normalized &#x3D;&#x3D; &amp;quot;github&amp;quot;:
            return &amp;quot;GitHub&amp;quot;
        return normalized

    def _execute_gitlab_command(self, company_vm: str, command: List[str]) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Execute GitLab management command in VM.&amp;quot;&amp;quot;&amp;quot;
        # This would SSH into the VM and execute gitlab-rails commands
        vm_manager &#x3D; VMManager(Path.home() / &amp;quot;.config&amp;quot; / &amp;quot;rave&amp;quot; / &amp;quot;vms&amp;quot;)
        config &#x3D; vm_manager._load_vm_config(company_vm)
        
        if not config:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_vm}&amp;#39; not found&amp;quot;}
        
        if not vm_manager._is_vm_running(company_vm):
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;VM &amp;#39;{company_vm}&amp;#39; is not running&amp;quot;}
        
        # Build SSH command to execute GitLab rails command
        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        ruby_script &#x3D; &amp;quot;\n&amp;quot;.join(command)

        ssh_cmd &#x3D; [
            &amp;quot;ssh&amp;quot;, &amp;quot;-i&amp;quot;, config[&amp;quot;keypair&amp;quot;], &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
            &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]), &amp;quot;root@localhost&amp;quot;,
            &amp;quot;gitlab-rails&amp;quot;, &amp;quot;runner&amp;quot;, &amp;quot;-&amp;quot;
        ]

        try:
            result &#x3D; subprocess.run(
                ssh_cmd,
                input&#x3D;ruby_script,
                capture_output&#x3D;True,
                text&#x3D;True,
                check&#x3D;True
            )
            return {&amp;quot;success&amp;quot;: True, &amp;quot;output&amp;quot;: result.stdout}
        except subprocess.CalledProcessError as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;GitLab command failed: {e.stderr}&amp;quot;}
    
    def add_user(
        self,
        email: str,
        oauth_id: str,
        access: str,
        company: Optional[str] &#x3D; None,
        *,
        name: Optional[str] &#x3D; None,
        metadata: Optional[Dict[str, str]] &#x3D; None,
        update_existing: bool &#x3D; False,
        provider: Optional[str] &#x3D; None,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Add or update a GitLab OAuth user.&amp;quot;&amp;quot;&amp;quot;

        access_level &#x3D; access.lower()
        valid_access &#x3D; [&amp;quot;admin&amp;quot;, &amp;quot;developer&amp;quot;, &amp;quot;guest&amp;quot;]
        if access_level not in valid_access:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: f&amp;quot;Invalid access level. Use: {&amp;#39;, &amp;#39;.join(valid_access)}&amp;quot;,
            }

        users_data &#x3D; self._load_users()
        existing_user &#x3D; self._find_user(users_data, email)
        is_update &#x3D; existing_user is not None

        if is_update and not update_existing:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} already exists&amp;quot;}

        now &#x3D; time.time()
        incoming_oauth &#x3D; (oauth_id or &amp;quot;&amp;quot;).strip() or email.split(&amp;quot;@&amp;quot;)[0]

        if is_update and existing_user.get(&amp;quot;oauth_id&amp;quot;) and existing_user[&amp;quot;oauth_id&amp;quot;] !&#x3D; incoming_oauth:
            return {
                &amp;quot;success&amp;quot;: False,
                &amp;quot;error&amp;quot;: (
                    f&amp;quot;OAuth ID mismatch for {email}: existing {existing_user[&amp;#39;oauth_id&amp;#39;]}, &amp;quot;
                    f&amp;quot;incoming {incoming_oauth}&amp;quot;
                ),
            }

        if is_update:
            user_record &#x3D; copy.deepcopy(existing_user)
        else:
            user_record &#x3D; {
                &amp;quot;email&amp;quot;: email,
                &amp;quot;created_at&amp;quot;: now,
            }

        user_record[&amp;quot;oauth_id&amp;quot;] &#x3D; (
            existing_user.get(&amp;quot;oauth_id&amp;quot;) if is_update and existing_user.get(&amp;quot;oauth_id&amp;quot;) else incoming_oauth
        )
        user_record[&amp;quot;access&amp;quot;] &#x3D; access_level
        user_record.setdefault(&amp;quot;created_at&amp;quot;, now)
        user_record[&amp;quot;updated_at&amp;quot;] &#x3D; now

        try:
            provider_value &#x3D; self._normalize_provider(
                provider or user_record.get(&amp;quot;provider&amp;quot;) or (existing_user or {}).get(&amp;quot;provider&amp;quot;)
            )
        except ValueError as exc:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: str(exc)}
        user_record[&amp;quot;provider&amp;quot;] &#x3D; provider_value

        if company is not None:
            user_record[&amp;quot;company&amp;quot;] &#x3D; company

        if name is not None:
            display_name &#x3D; name.strip()
            if display_name:
                user_record[&amp;quot;name&amp;quot;] &#x3D; display_name
            else:
                user_record.pop(&amp;quot;name&amp;quot;, None)

        if metadata is not None:
            filtered_metadata &#x3D; {
                str(k): str(v)
                for k, v in metadata.items()
                if v is not None and str(v).strip()
            }
            if filtered_metadata:
                user_record[&amp;quot;metadata&amp;quot;] &#x3D; filtered_metadata
            else:
                user_record.pop(&amp;quot;metadata&amp;quot;, None)

        vm_company &#x3D; company if company is not None else user_record.get(&amp;quot;company&amp;quot;)
        if vm_company:
            username_base &#x3D; email.split(&amp;quot;@&amp;quot;)[0]
            username_base &#x3D; re.sub(r&amp;quot;[^a-zA-Z0-9_]&amp;quot;, &amp;quot;-&amp;quot;, username_base)
            if not username_base:
                username_base &#x3D; &amp;quot;user&amp;quot;

            display_name_literal &#x3D; (
                json.dumps(user_record.get(&amp;quot;name&amp;quot;))
                if user_record.get(&amp;quot;name&amp;quot;)
                else &amp;quot;nil&amp;quot;
            )

            script_lines &#x3D; [
                &amp;quot;require &amp;#39;securerandom&amp;#39;&amp;quot;,
                &amp;quot;&amp;quot;,
                f&amp;quot;email &#x3D; {json.dumps(email)}&amp;quot;,
                f&amp;quot;oauth_id &#x3D; {json.dumps(user_record[&amp;#39;oauth_id&amp;#39;])}&amp;quot;,
                f&amp;quot;provider &#x3D; {json.dumps(provider_value)}&amp;quot;,
                f&amp;quot;username_base &#x3D; {json.dumps(username_base)}&amp;quot;,
                &amp;quot;username &#x3D; username_base&amp;quot;,
                &amp;quot;suffix &#x3D; 0&amp;quot;,
                &amp;quot;while User.exists?(username: username)&amp;quot;,
                &amp;quot;  suffix +&#x3D; 1&amp;quot;,
                &amp;quot;  username &#x3D; \&amp;quot;#{username_base}-#{suffix}\&amp;quot;&amp;quot;,
                &amp;quot;end&amp;quot;,
                f&amp;quot;display_name &#x3D; {display_name_literal}&amp;quot;,
                &amp;quot;&amp;quot;,
                &amp;quot;password &#x3D; SecureRandom.hex(20)&amp;quot;,
                &amp;quot;user &#x3D; User.find_by(email: email)&amp;quot;,
                &amp;quot;&amp;quot;,
                &amp;quot;if user&amp;quot;,
                &amp;quot;  user.external &#x3D; true&amp;quot;,
                &amp;quot;  user.name &#x3D; display_name if display_name &amp;amp;&amp;amp; !display_name.empty?&amp;quot;,
                &amp;quot;  if user.encrypted_password.blank?&amp;quot;,
                &amp;quot;    user.password &#x3D; password&amp;quot;,
                &amp;quot;    user.password_confirmation &#x3D; password&amp;quot;,
                &amp;quot;  end&amp;quot;,
                &amp;quot;  user.skip_confirmation! if user.respond_to?(:skip_confirmation!)&amp;quot;,
                &amp;quot;  user.build_namespace(path: username, name: username) unless user.namespace&amp;quot;,
                &amp;quot;  user.save!&amp;quot;,
                &amp;quot;else&amp;quot;,
                &amp;quot;  user &#x3D; User.new(&amp;quot;,
                &amp;quot;    email: email,&amp;quot;,
                &amp;quot;    name: display_name || username,&amp;quot;,
                &amp;quot;    username: username,&amp;quot;,
                &amp;quot;    external: true,&amp;quot;,
                &amp;quot;    password: password,&amp;quot;,
                &amp;quot;    password_confirmation: password&amp;quot;,
                &amp;quot;  )&amp;quot;,
                &amp;quot;  user.skip_confirmation! if user.respond_to?(:skip_confirmation!)&amp;quot;,
                &amp;quot;  user.build_namespace(path: username, name: username)&amp;quot;,
                &amp;quot;  user.save!&amp;quot;,
                &amp;quot;end&amp;quot;,
                &amp;quot;&amp;quot;,
                &amp;quot;identity &#x3D; user.identities.find_or_initialize_by(provider: provider)&amp;quot;,
                &amp;quot;identity.extern_uid &#x3D; oauth_id&amp;quot;,
                &amp;quot;identity.save!&amp;quot;,
                &amp;quot;&amp;quot;,
                &amp;quot;puts user.id&amp;quot;,
            ]

            gitlab_cmd &#x3D; [&amp;quot;\n&amp;quot;.join(script_lines)]
            result &#x3D; self._execute_gitlab_command(vm_company, gitlab_cmd)
            if not result[&amp;quot;success&amp;quot;]:
                return result

        if is_update:
            existing_user.clear()
            existing_user.update(user_record)
        else:
            users_data[&amp;quot;users&amp;quot;].append(user_record)

        self._save_users(users_data)

        payload &#x3D; {&amp;quot;success&amp;quot;: True, &amp;quot;user&amp;quot;: user_record.copy()}
        if is_update:
            payload[&amp;quot;updated&amp;quot;] &#x3D; True
        else:
            payload[&amp;quot;created&amp;quot;] &#x3D; True
        return payload
    
    def remove_user(self, email: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Remove a user.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        user &#x3D; self._find_user(users_data, email)
        
        if not user:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} not found&amp;quot;}
        
        # Remove from GitLab if company is specified
        if user.get(&amp;quot;company&amp;quot;):
            gitlab_cmd &#x3D; [
                f&amp;quot;user &#x3D; User.find_by(email: &amp;#39;{email}&amp;#39;); user.destroy if user&amp;quot;
            ]
            
            result &#x3D; self._execute_gitlab_command(user[&amp;quot;company&amp;quot;], gitlab_cmd)
            # Continue even if GitLab removal fails (VM might be down)
        
        # Remove from local database
        users_data[&amp;quot;users&amp;quot;] &#x3D; [u for u in users_data[&amp;quot;users&amp;quot;] if u[&amp;quot;email&amp;quot;] !&#x3D; email]
        self._save_users(users_data)
        
        return {&amp;quot;success&amp;quot;: True}
    
    def list_users(self, company: Optional[str] &#x3D; None) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;List all users, optionally filtered by company.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        users &#x3D; users_data[&amp;quot;users&amp;quot;]
        
        for user in users:
            if not user.get(&amp;quot;provider&amp;quot;):
                user[&amp;quot;provider&amp;quot;] &#x3D; self.default_provider

        if company:
            users &#x3D; [u for u in users if u.get(&amp;quot;company&amp;quot;) &#x3D;&#x3D; company]
        
        return {&amp;quot;success&amp;quot;: True, &amp;quot;users&amp;quot;: users}
    
    def get_user(self, email: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get user details.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        user &#x3D; self._find_user(users_data, email)
        
        if not user:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} not found&amp;quot;}
        
        if not user.get(&amp;quot;provider&amp;quot;):
            user[&amp;quot;provider&amp;quot;] &#x3D; self.default_provider

        return {&amp;quot;success&amp;quot;: True, &amp;quot;user&amp;quot;: user}
    
    def config_user(self, email: str, access: Optional[str] &#x3D; None) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Configure user settings.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        user &#x3D; self._find_user(users_data, email)
        
        if not user:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} not found&amp;quot;}
        
        # Update access level
        if access:
            valid_access &#x3D; [&amp;quot;admin&amp;quot;, &amp;quot;developer&amp;quot;, &amp;quot;guest&amp;quot;]
            if access not in valid_access:
                return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Invalid access level. Use: {&amp;#39;, &amp;#39;.join(valid_access)}&amp;quot;}
            
            user[&amp;quot;access&amp;quot;] &#x3D; access
            
            # Update in GitLab if company is specified
            if user.get(&amp;quot;company&amp;quot;):
                # Map access levels to GitLab access levels
                gitlab_access &#x3D; {
                    &amp;quot;admin&amp;quot;: &amp;quot;50&amp;quot;,    # Owner
                    &amp;quot;developer&amp;quot;: &amp;quot;30&amp;quot;, # Developer
                    &amp;quot;guest&amp;quot;: &amp;quot;10&amp;quot;     # Guest
                }
                
                gitlab_cmd &#x3D; [
                    f&amp;quot;user &#x3D; User.find_by(email: &amp;#39;{email}&amp;#39;); project &#x3D; Project.first; project.add_developer(user) if user &amp;amp;&amp;amp; project&amp;quot;
                ]
                
                result &#x3D; self._execute_gitlab_command(user[&amp;quot;company&amp;quot;], gitlab_cmd)
                # Continue even if GitLab update fails
        
        # Save updated user data
        self._save_users(users_data)
        
        return {&amp;quot;success&amp;quot;: True, &amp;quot;user&amp;quot;: user}

    # Enhanced user management features
    
    def bulk_add_users(
        self,
        users_file: str,
        company: Optional[str] &#x3D; None,
        default_metadata: Optional[Dict[str, str]] &#x3D; None,
        provider: Optional[str] &#x3D; None,
    ) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Add multiple users from CSV/JSON file.&amp;quot;&amp;quot;&amp;quot;
        file_path &#x3D; Path(users_file).expanduser()
        if not file_path.exists():
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;File not found: {file_path}&amp;quot;}
        
        added_users: List[Dict[str, any]] &#x3D; []
        updated_users: List[Dict[str, any]] &#x3D; []
        failed_users: List[Dict[str, any]] &#x3D; []
        skipped_users: List[Dict[str, any]] &#x3D; []

        def _clean_metadata(meta: Optional[Dict[str, str]]) -&amp;gt; Optional[Dict[str, str]]:
            if not meta:
                return None
            cleaned &#x3D; {
                str(k): str(v)
                for k, v in meta.items()
                if v is not None and str(v).strip()
            }
            return cleaned or None

        default_meta_clean &#x3D; _clean_metadata(default_metadata)

        try:
            normalized_default_provider &#x3D; self._normalize_provider(provider)
        except ValueError as exc:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: str(exc)}

        try:
            if file_path.suffix.lower() &#x3D;&#x3D; &amp;#39;.json&amp;#39;:
                import_data &#x3D; json.loads(file_path.read_text())
                users_to_add &#x3D; import_data.get(&amp;quot;users&amp;quot;, [])
            elif file_path.suffix.lower() &#x3D;&#x3D; &amp;#39;.csv&amp;#39;:
                import csv
                users_to_add &#x3D; []
                with open(file_path, &amp;#39;r&amp;#39;) as csvfile:
                    reader &#x3D; csv.DictReader(csvfile)
                    for row in reader:
                        base_fields &#x3D; {&amp;quot;email&amp;quot;, &amp;quot;oauth_id&amp;quot;, &amp;quot;access&amp;quot;, &amp;quot;name&amp;quot;}
                        metadata &#x3D; {
                            key: value
                            for key, value in row.items()
                            if key not in base_fields and value is not None and value.strip()
                        }
                        users_to_add.append({
                            &amp;quot;email&amp;quot;: row.get(&amp;quot;email&amp;quot;, &amp;quot;&amp;quot;).strip(),
                            &amp;quot;oauth_id&amp;quot;: row.get(&amp;quot;oauth_id&amp;quot;, row.get(&amp;quot;email&amp;quot;, &amp;quot;&amp;quot;).split(&amp;quot;@&amp;quot;)[0]),
                            &amp;quot;access&amp;quot;: row.get(&amp;quot;access&amp;quot;, &amp;quot;developer&amp;quot;).lower(),
                            &amp;quot;name&amp;quot;: row.get(&amp;quot;name&amp;quot;, &amp;quot;&amp;quot;).strip(),
                            &amp;quot;metadata&amp;quot;: metadata
                        })
            else:
                return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Unsupported file format. Use .json or .csv&amp;quot;}
            
            for user_data in users_to_add:
                email &#x3D; (user_data.get(&amp;quot;email&amp;quot;) or &amp;quot;&amp;quot;).strip()
                if not email:
                    failed_users.append({&amp;quot;error&amp;quot;: &amp;quot;Missing email&amp;quot;, &amp;quot;data&amp;quot;: user_data})
                    continue

                oauth_value &#x3D; (user_data.get(&amp;quot;oauth_id&amp;quot;) or email.split(&amp;quot;@&amp;quot;)[0]).strip()
                access_value &#x3D; (user_data.get(&amp;quot;access&amp;quot;) or &amp;quot;developer&amp;quot;).lower()

                raw_name &#x3D; user_data.get(&amp;quot;name&amp;quot;)
                if isinstance(raw_name, str):
                    cleaned_name &#x3D; raw_name.strip()
                    name_value: Optional[str] &#x3D; cleaned_name or None
                elif raw_name is None:
                    name_value &#x3D; None
                else:
                    name_value &#x3D; str(raw_name).strip() or None

                metadata_value &#x3D; user_data.get(&amp;quot;metadata&amp;quot;)
                if isinstance(metadata_value, dict):
                    metadata_value &#x3D; _clean_metadata(metadata_value)
                elif metadata_value is None:
                    base_fields &#x3D; {&amp;quot;email&amp;quot;, &amp;quot;oauth_id&amp;quot;, &amp;quot;access&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;metadata&amp;quot;, &amp;quot;company&amp;quot;}
                    inferred &#x3D; {
                        key: value
                        for key, value in user_data.items()
                        if key not in base_fields and value is not None and str(value).strip()
                    }
                    metadata_value &#x3D; _clean_metadata(inferred)
                else:
                    metadata_value &#x3D; None

                combined_metadata &#x3D; None
                if default_meta_clean:
                    combined_metadata &#x3D; dict(default_meta_clean)
                if metadata_value:
                    combined_metadata &#x3D; combined_metadata or {}
                    combined_metadata.update(metadata_value)

                row_company &#x3D; user_data.get(&amp;quot;company&amp;quot;)
                if isinstance(row_company, str):
                    row_company &#x3D; row_company.strip() or None
                elif row_company is not None:
                    row_company &#x3D; str(row_company).strip() or None

                target_company &#x3D; company or row_company

                row_provider &#x3D; user_data.get(&amp;quot;provider&amp;quot;)
                try:
                    normalized_provider &#x3D; self._normalize_provider(
                        row_provider or normalized_default_provider
                    )
                except ValueError as exc:
                    failed_users.append({&amp;quot;email&amp;quot;: email, &amp;quot;error&amp;quot;: str(exc)})
                    continue

                add_result &#x3D; self.add_user(
                    email&#x3D;email,
                    oauth_id&#x3D;oauth_value,
                    access&#x3D;access_value,
                    company&#x3D;target_company,
                    name&#x3D;name_value,
                    metadata&#x3D;combined_metadata,
                    update_existing&#x3D;True,
                    provider&#x3D;normalized_provider,
                )
                
                if add_result[&amp;quot;success&amp;quot;]:
                    if add_result.get(&amp;quot;updated&amp;quot;):
                        updated_users.append(add_result[&amp;quot;user&amp;quot;])
                    else:
                        added_users.append(add_result[&amp;quot;user&amp;quot;])
                else:
                    failed_users.append({&amp;quot;email&amp;quot;: email, &amp;quot;error&amp;quot;: add_result[&amp;quot;error&amp;quot;]})
                    
        except Exception as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to process file: {e}&amp;quot;}
        
        return {
            &amp;quot;success&amp;quot;: True,
            &amp;quot;added&amp;quot;: len(added_users),
            &amp;quot;updated&amp;quot;: len(updated_users),
            &amp;quot;failed&amp;quot;: len(failed_users),
            &amp;quot;skipped&amp;quot;: len(skipped_users),
            &amp;quot;details&amp;quot;: {
                &amp;quot;added&amp;quot;: added_users,
                &amp;quot;updated&amp;quot;: updated_users,
                &amp;quot;failed&amp;quot;: failed_users,
                &amp;quot;skipped&amp;quot;: skipped_users,
            },
        }
    
    def get_user_activity(self, email: str, company: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get user activity from GitLab.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        user &#x3D; self._find_user(users_data, email)
        
        if not user:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} not found&amp;quot;}
        
        if not company:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Company parameter required for activity lookup&amp;quot;}
        
        # GitLab Rails command to get user activity
        gitlab_cmd &#x3D; [
            f&amp;quot;&amp;quot;&amp;quot;
            user &#x3D; User.find_by(email: &amp;#39;{email}&amp;#39;)
            if user
              puts JSON.generate({{
                id: user.id,
                last_sign_in_at: user.last_sign_in_at&amp;amp;.iso8601,
                sign_in_count: user.sign_in_count,
                created_at: user.created_at&amp;amp;.iso8601,
                current_sign_in_at: user.current_sign_in_at&amp;amp;.iso8601,
                projects_count: user.projects.count,
                groups_count: user.groups.count
              }})
            else
              puts &amp;#39;null&amp;#39;
            end
            &amp;quot;&amp;quot;&amp;quot;
        ]
        
        result &#x3D; self._execute_gitlab_command(company, gitlab_cmd)
        if not result[&amp;quot;success&amp;quot;]:
            return result
        
        try:
            activity_data &#x3D; json.loads(result[&amp;quot;output&amp;quot;].strip())
            return {&amp;quot;success&amp;quot;: True, &amp;quot;activity&amp;quot;: activity_data}
        except json.JSONDecodeError:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Invalid response from GitLab&amp;quot;}
    
    def assign_user_to_projects(self, email: str, company: str, project_names: List[str], access_level: str &#x3D; &amp;quot;developer&amp;quot;) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Assign user to specific projects within a company VM.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        user &#x3D; self._find_user(users_data, email)
        
        if not user:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;User {email} not found&amp;quot;}
        
        # Map access levels to GitLab access levels
        gitlab_access_levels &#x3D; {
            &amp;quot;guest&amp;quot;: 10,
            &amp;quot;reporter&amp;quot;: 20,
            &amp;quot;developer&amp;quot;: 30,
            &amp;quot;maintainer&amp;quot;: 40,
            &amp;quot;owner&amp;quot;: 50
        }
        
        access_level_id &#x3D; gitlab_access_levels.get(access_level.lower(), 30)
        results &#x3D; {&amp;quot;success&amp;quot;: True, &amp;quot;assigned&amp;quot;: [], &amp;quot;failed&amp;quot;: []}
        
        for project_name in project_names:
            gitlab_cmd &#x3D; [
                f&amp;quot;&amp;quot;&amp;quot;
                user &#x3D; User.find_by(email: &amp;#39;{email}&amp;#39;)
                project &#x3D; Project.find_by(name: &amp;#39;{project_name}&amp;#39;) || Project.find_by(path: &amp;#39;{project_name}&amp;#39;)
                
                if user &amp;amp;&amp;amp; project
                  member &#x3D; project.members.find_by(user: user)
                  if member
                    member.update(access_level: {access_level_id})
                    puts &amp;quot;Updated access for {{user.email}} in {{project.name}}&amp;quot;
                  else
                    project.add_developer(user, {access_level_id})
                    puts &amp;quot;Added {{user.email}} to {{project.name}}&amp;quot;
                  end
                else
                  puts &amp;quot;Error: User or project not found&amp;quot;
                end
                &amp;quot;&amp;quot;&amp;quot;
            ]
            
            result &#x3D; self._execute_gitlab_command(company, gitlab_cmd)
            if result[&amp;quot;success&amp;quot;] and &amp;quot;Error:&amp;quot; not in result[&amp;quot;output&amp;quot;]:
                results[&amp;quot;assigned&amp;quot;].append(project_name)
            else:
                results[&amp;quot;failed&amp;quot;].append({&amp;quot;project&amp;quot;: project_name, &amp;quot;error&amp;quot;: result.get(&amp;quot;error&amp;quot;, &amp;quot;Assignment failed&amp;quot;)})
        
        return results
    
    def get_user_permissions(self, email: str, company: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get detailed user permissions across all projects.&amp;quot;&amp;quot;&amp;quot;
        gitlab_cmd &#x3D; [
            f&amp;quot;&amp;quot;&amp;quot;
            user &#x3D; User.find_by(email: &amp;#39;{email}&amp;#39;)
            if user
              permissions &#x3D; {{
                user: {{
                  id: user.id,
                  email: user.email,
                  name: user.name,
                  admin: user.admin?,
                  blocked: user.blocked?
                }},
                projects: [],
                groups: []
              }}
              
              # Get project memberships
              user.members.includes(:source).each do |member|
                if member.source.is_a?(Project)
                  permissions[:projects] &amp;lt;&amp;lt; {{
                    id: member.source.id,
                    name: member.source.name,
                    path: member.source.path,
                    access_level: member.access_level,
                    access_level_name: member.human_access
                  }}
                end
              end
              
              # Get group memberships  
              user.group_members.includes(:source).each do |member|
                permissions[:groups] &amp;lt;&amp;lt; {{
                  id: member.source.id,
                  name: member.source.name,
                  path: member.source.path,
                  access_level: member.access_level,
                  access_level_name: member.human_access
                }}
              end
              
              puts JSON.generate(permissions)
            else
              puts &amp;#39;null&amp;#39;
            end
            &amp;quot;&amp;quot;&amp;quot;
        ]
        
        result &#x3D; self._execute_gitlab_command(company, gitlab_cmd)
        if not result[&amp;quot;success&amp;quot;]:
            return result
        
        try:
            permissions_data &#x3D; json.loads(result[&amp;quot;output&amp;quot;].strip())
            return {&amp;quot;success&amp;quot;: True, &amp;quot;permissions&amp;quot;: permissions_data}
        except json.JSONDecodeError:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Invalid response from GitLab&amp;quot;}
    
    def sync_users_with_gitlab(self, company: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Synchronize local user database with GitLab users.&amp;quot;&amp;quot;&amp;quot;
        provider_list &#x3D; sorted(self.supported_providers)
        provider_array &#x3D; &amp;quot;, &amp;quot;.join(f&amp;quot;&amp;#39;{p}&amp;#39;&amp;quot; for p in provider_list)

        gitlab_cmd &#x3D; [
            f&amp;quot;&amp;quot;&amp;quot;
            providers &#x3D; [{provider_array}]
            users &#x3D; User.all.map do |user|
              identity &#x3D; user.identities.where(provider: providers).first
              {
                id: user.id,
                email: user.email,
                name: user.name,
                username: user.username,
                provider: identity&amp;amp;.provider,
                extern_uid: identity&amp;amp;.extern_uid,
                created_at: user.created_at&amp;amp;.iso8601,
                last_sign_in_at: user.last_sign_in_at&amp;amp;.iso8601,
                admin: user.admin?,
                blocked: user.blocked?
              }
            end
            puts JSON.generate(users)
            &amp;quot;&amp;quot;&amp;quot;
        ]
        
        result &#x3D; self._execute_gitlab_command(company, gitlab_cmd)
        if not result[&amp;quot;success&amp;quot;]:
            return result
        
        try:
            gitlab_users &#x3D; json.loads(result[&amp;quot;output&amp;quot;].strip())
            users_data &#x3D; self._load_users()
            
            sync_results &#x3D; {&amp;quot;success&amp;quot;: True, &amp;quot;synced&amp;quot;: 0, &amp;quot;added&amp;quot;: 0, &amp;quot;updated&amp;quot;: 0}
            
            for gitlab_user in gitlab_users:
                email &#x3D; gitlab_user.get(&amp;quot;email&amp;quot;)
                if not email:
                    continue
                
                local_user &#x3D; self._find_user(users_data, email)
                
                if local_user:
                    # Update existing user
                    local_user[&amp;quot;last_sync&amp;quot;] &#x3D; time.time()
                    local_user[&amp;quot;gitlab_id&amp;quot;] &#x3D; gitlab_user[&amp;quot;id&amp;quot;]
                    local_user[&amp;quot;last_sign_in&amp;quot;] &#x3D; gitlab_user.get(&amp;quot;last_sign_in_at&amp;quot;)
                    if not local_user.get(&amp;quot;provider&amp;quot;):
                        local_user[&amp;quot;provider&amp;quot;] &#x3D; gitlab_user.get(&amp;quot;provider&amp;quot;) or self.default_provider
                    sync_results[&amp;quot;updated&amp;quot;] +&#x3D; 1
                else:
                    # Add new user found in GitLab
                    new_user &#x3D; {
                        &amp;quot;email&amp;quot;: email,
                        &amp;quot;oauth_id&amp;quot;: gitlab_user.get(&amp;quot;extern_uid&amp;quot;, email.split(&amp;quot;@&amp;quot;)[0]),
                        &amp;quot;access&amp;quot;: &amp;quot;developer&amp;quot;,  # Default access
                        &amp;quot;company&amp;quot;: company,
                        &amp;quot;created_at&amp;quot;: time.time(),
                        &amp;quot;gitlab_id&amp;quot;: gitlab_user[&amp;quot;id&amp;quot;],
                        &amp;quot;last_sync&amp;quot;: time.time(),
                        &amp;quot;synced_from_gitlab&amp;quot;: True,
                        &amp;quot;provider&amp;quot;: gitlab_user.get(&amp;quot;provider&amp;quot;) or self.default_provider
                    }
                    users_data[&amp;quot;users&amp;quot;].append(new_user)
                    sync_results[&amp;quot;added&amp;quot;] +&#x3D; 1
                
                sync_results[&amp;quot;synced&amp;quot;] +&#x3D; 1
            
            self._save_users(users_data)
            return sync_results
            
        except json.JSONDecodeError as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Invalid response from GitLab: {e}&amp;quot;}
    
    def export_users(self, output_file: str, company: Optional[str] &#x3D; None, format: str &#x3D; &amp;quot;json&amp;quot;) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Export users to file.&amp;quot;&amp;quot;&amp;quot;
        users_data &#x3D; self._load_users()
        users &#x3D; users_data[&amp;quot;users&amp;quot;]
        
        if company:
            users &#x3D; [u for u in users if u.get(&amp;quot;company&amp;quot;) &#x3D;&#x3D; company]
        
        output_path &#x3D; Path(output_file).expanduser()
        
        try:
            if format.lower() &#x3D;&#x3D; &amp;quot;json&amp;quot;:
                output_path.write_text(json.dumps({&amp;quot;users&amp;quot;: users, &amp;quot;exported_at&amp;quot;: datetime.now().isoformat()}, indent&#x3D;2))
            elif format.lower() &#x3D;&#x3D; &amp;quot;csv&amp;quot;:
                import csv
                with open(output_path, &amp;#39;w&amp;#39;, newline&#x3D;&amp;#39;&amp;#39;) as csvfile:
                    if users:
                        fieldnames &#x3D; users[0].keys()
                        writer &#x3D; csv.DictWriter(csvfile, fieldnames&#x3D;fieldnames)
                        writer.writeheader()
                        for user in users:
                            writer.writerow(user)
            else:
                return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: &amp;quot;Unsupported format. Use &amp;#39;json&amp;#39; or &amp;#39;csv&amp;#39;&amp;quot;}
                
            return {&amp;quot;success&amp;quot;: True, &amp;quot;file&amp;quot;: str(output_path), &amp;quot;count&amp;quot;: len(users)}
            
        except Exception as e:
            return {&amp;quot;success&amp;quot;: False, &amp;quot;error&amp;quot;: f&amp;quot;Failed to export users: {e}&amp;quot;}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-5">
                <div class="file-header">📄 oauth_manager.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;
OAuth Manager - Shows status of pre-configured OAuth integrations
OAuth configurations are baked into the VM, this just provides visibility.
&amp;quot;&amp;quot;&amp;quot;

import subprocess
from pathlib import Path
from typing import Dict, Optional


class OAuthManager:
    &amp;quot;&amp;quot;&amp;quot;Manages OAuth integration status (read-only, configs are baked in).&amp;quot;&amp;quot;&amp;quot;
    
    def __init__(self):
        pass
    
    def _check_vm_oauth_status(self, company_name: str, service: str) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Check OAuth status for a service in a VM.&amp;quot;&amp;quot;&amp;quot;
        # Import here to avoid circular dependency
        from vm_manager import VMManager
        
        vm_manager &#x3D; VMManager(Path.home() / &amp;quot;.config&amp;quot; / &amp;quot;rave&amp;quot; / &amp;quot;vms&amp;quot;)
        config &#x3D; vm_manager._load_vm_config(company_name)
        
        if not config:
            return {&amp;quot;configured&amp;quot;: False, &amp;quot;status&amp;quot;: &amp;quot;VM not found&amp;quot;}
        
        if not vm_manager._is_vm_running(company_name):
            return {&amp;quot;configured&amp;quot;: False, &amp;quot;status&amp;quot;: &amp;quot;VM not running&amp;quot;}
        
        # Check service-specific OAuth configuration
        ports &#x3D; config[&amp;quot;ports&amp;quot;]
        ssh_cmd &#x3D; [
            &amp;quot;ssh&amp;quot;, &amp;quot;-i&amp;quot;, config[&amp;quot;keypair&amp;quot;], &amp;quot;-o&amp;quot;, &amp;quot;StrictHostKeyChecking&#x3D;no&amp;quot;,
            &amp;quot;-p&amp;quot;, str(ports[&amp;quot;ssh&amp;quot;]), &amp;quot;root@localhost&amp;quot;
        ]
        
        if service &#x3D;&#x3D; &amp;quot;penpot&amp;quot;:
            # Check if Penpot is configured with GitLab OAuth
            check_cmd &#x3D; ssh_cmd + [&amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, f&amp;quot;http://localhost/penpot/api/auth/providers&amp;quot;]
        elif service &#x3D;&#x3D; &amp;quot;element&amp;quot;:
            # Check if Element is configured with GitLab OAuth
            check_cmd &#x3D; ssh_cmd + [&amp;quot;cat&amp;quot;, &amp;quot;/etc/element-web/config.json&amp;quot;]
        else:
            return {&amp;quot;configured&amp;quot;: False, &amp;quot;status&amp;quot;: f&amp;quot;Unknown service: {service}&amp;quot;}
        
        try:
            result &#x3D; subprocess.run(check_cmd, capture_output&#x3D;True, text&#x3D;True, timeout&#x3D;10)
            if result.returncode &#x3D;&#x3D; 0:
                # Parse response to determine if GitLab OAuth is configured
                if service &#x3D;&#x3D; &amp;quot;penpot&amp;quot;:
                    configured &#x3D; &amp;quot;gitlab&amp;quot; in result.stdout.lower()
                elif service &#x3D;&#x3D; &amp;quot;element&amp;quot;:
                    configured &#x3D; any(
                        marker in result.stdout
                        for marker in (&amp;quot;google_oauth2&amp;quot;, &amp;quot;github&amp;quot;, &amp;quot;oauth2_generic&amp;quot;)
                    )
                else:
                    configured &#x3D; False
                
                return {
                    &amp;quot;configured&amp;quot;: configured,
                    &amp;quot;provider&amp;quot;: &amp;quot;gitlab&amp;quot; if configured else &amp;quot;none&amp;quot;,
                    &amp;quot;status&amp;quot;: &amp;quot;configured&amp;quot; if configured else &amp;quot;not configured&amp;quot;
                }
            else:
                return {&amp;quot;configured&amp;quot;: False, &amp;quot;status&amp;quot;: &amp;quot;service not accessible&amp;quot;}
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            return {&amp;quot;configured&amp;quot;: False, &amp;quot;status&amp;quot;: &amp;quot;check failed&amp;quot;}
    
    def get_status(self, service: Optional[str] &#x3D; None) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;Get OAuth configuration status.&amp;quot;&amp;quot;&amp;quot;
        # Get all VMs
        from vm_manager import VMManager
        vm_manager &#x3D; VMManager(Path.home() / &amp;quot;.config&amp;quot; / &amp;quot;rave&amp;quot; / &amp;quot;vms&amp;quot;)
        vm_statuses &#x3D; vm_manager.status_all_vms()
        
        if not vm_statuses:
            return {&amp;quot;success&amp;quot;: True, &amp;quot;configs&amp;quot;: {}}
        
        configs &#x3D; {}
        services &#x3D; [service] if service else [&amp;quot;penpot&amp;quot;, &amp;quot;element&amp;quot;]
        
        for company_name, vm_status in vm_statuses.items():
            if not vm_status[&amp;quot;running&amp;quot;]:
                continue
                
            for svc in services:
                key &#x3D; f&amp;quot;{svc} ({company_name})&amp;quot;
                status &#x3D; self._check_vm_oauth_status(company_name, svc)
                configs[key] &#x3D; status
        
        return {&amp;quot;success&amp;quot;: True, &amp;quot;configs&amp;quot;: configs}
    
    def configure_service(self, service: str, provider: str, client_id: str, 
                         client_secret: str, redirect_uri: Optional[str] &#x3D; None) -&amp;gt; Dict[str, any]:
        &amp;quot;&amp;quot;&amp;quot;OAuth configuration is baked into VMs - this is not supported.&amp;quot;&amp;quot;&amp;quot;
        return {
            &amp;quot;success&amp;quot;: False, 
            &amp;quot;error&amp;quot;: &amp;quot;OAuth configuration is pre-baked into VMs. Use &amp;#39;rave oauth status&amp;#39; to check current setup.&amp;quot;
        }
</pre>
                </div>
            </div>
            <div class="file-section" id="file-6">
                <div class="file-header">📄 README.md</div>
                <div class="file-content">
                    <pre># RAVE CLI

Comprehensive CLI for managing RAVE (Reproducible AI Virtual Environment) company development environments.

## Features

- **VM Management**: Create, start, stop, reset company development VMs
- **User Management**: Add/remove users via GitLab OAuth integration  
- **SSH &amp;amp; Logging**: Direct access to VMs and service logs
- **Pre-configured Services**: GitLab, NATS, PostgreSQL, Redis, nginx with SSL
- **OAuth Integration**: Penpot and Element pre-configured with GitLab OAuth

## Installation

&#x60;&#x60;&#x60;bash
cd /home/nathan/Projects/rave/cli
pip install -r requirements.txt
&#x60;&#x60;&#x60;

Add to PATH:
&#x60;&#x60;&#x60;bash
export PATH&#x3D;&amp;quot;$PATH:/home/nathan/Projects/rave/cli&amp;quot;
&#x60;&#x60;&#x60;

## Quick Start

&#x60;&#x60;&#x60;bash
# Create a company development environment
rave vm create acme-corp --keypair ~/.ssh/id_ed25519

# Start the VM
rave vm start acme-corp

# Check status
rave vm status acme-corp

# SSH into VM
rave vm ssh acme-corp

# View logs
rave vm logs acme-corp nginx --follow

# Add users
rave user add john@acme-corp.com --oauth-id 12345 --access developer --company acme-corp

# List users
rave user list --company acme-corp
&#x60;&#x60;&#x60;

## Commands

### VM Management
- &#x60;rave vm create &amp;lt;company&amp;gt; --keypair &amp;lt;path&amp;gt;&#x60; - Create company VM
- &#x60;rave vm start &amp;lt;company&amp;gt;&#x60; - Start VM
- &#x60;rave vm stop &amp;lt;company&amp;gt;&#x60; - Stop VM  
- &#x60;rave vm status [company] [--all]&#x60; - Show VM status
- &#x60;rave vm reset &amp;lt;company&amp;gt;&#x60; - Reset VM to clean state
- &#x60;rave vm ssh &amp;lt;company&amp;gt;&#x60; - SSH into VM
- &#x60;rave vm logs &amp;lt;company&amp;gt; [service] [options]&#x60; - View service logs

### User Management
- &#x60;rave user add &amp;lt;email&amp;gt; --oauth-id &amp;lt;id&amp;gt; --access &amp;lt;level&amp;gt;&#x60; - Add user
- &#x60;rave user remove &amp;lt;email&amp;gt;&#x60; - Remove user
- &#x60;rave user list [--company &amp;lt;name&amp;gt;]&#x60; - List users
- &#x60;rave user config &amp;lt;email&amp;gt; --access &amp;lt;level&amp;gt;&#x60; - Change user access
- &#x60;rave user show &amp;lt;email&amp;gt;&#x60; - Show user details

### OAuth Status
- &#x60;rave oauth status [service]&#x60; - Show OAuth configuration status

## Architecture

Each company VM includes:
- **GitLab** (port offset + 80/443) with OAuth provider
- **NATS JetStream** (internal) for event streaming
- **PostgreSQL** (internal) for data storage
- **Redis** (internal) for caching
- **nginx** (reverse proxy) with SSL certificates
- **Penpot** (pre-configured with GitLab OAuth)
- **Element** (pre-configured with GitLab OAuth)

VMs are isolated by port ranges starting from 8100, incrementing by 10 per company.

## Configuration

CLI configuration stored in &#x60;~/.config/rave/&#x60;:
- &#x60;config.json&#x60; - Global settings
- &#x60;vms/&#x60; - VM configurations
- &#x60;users.json&#x60; - User database

## Development

The CLI integrates with the existing RAVE NixOS configuration system, building VMs using &#x60;nix build .#development&#x60;.</pre>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load self-contained bundle (includes React, ReactDOM, React Arborist, and Lucide React) -->
    <script src="assets/scribe-tree-bundle.js"></script>
    
    <script>
        // File data from Handlebars template
        const fileData = [
            {
                path: "DIRECTORY_MAP.txt",
                icon: "file-text",
                index: 0,
                size: "1.39 KB",
                tokens: "364",
                score: "1.00"
            },
            {
                path: "vm_manager.py",
                icon: "file-code",
                index: 1,
                size: "47.55 KB",
                tokens: "8,927",
                score: "0.88"
            },
            {
                path: "platform_utils.py",
                icon: "file-code",
                index: 2,
                size: "9.91 KB",
                tokens: "1,911",
                score: "0.88"
            },
            {
                path: "user_manager.py",
                icon: "file-code",
                index: 3,
                size: "29.89 KB",
                tokens: "5,300",
                score: "0.88"
            },
            {
                path: "oauth_manager.py",
                icon: "file-code",
                index: 4,
                size: "4.17 KB",
                tokens: "774",
                score: "0.83"
            },
            {
                path: "README.md",
                icon: "book-open",
                index: 5,
                size: "2.64 KB",
                tokens: "507",
                score: "0.28"
            }
        ];

        // Initialize the file tree
        document.addEventListener('DOMContentLoaded', function() {
            if (window.ScribeFileTree) {
                const fileTree = new window.ScribeFileTree();
                const success = fileTree.renderTree('file-tree-container', fileData);
                
                if (success) {
                    console.log('File tree rendered successfully');
                } else {
                    console.error('Failed to render file tree');
                    // Fallback to simple list
                    const container = document.getElementById('file-tree-container');
                    if (container) {
                        container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Tree view failed to load. Use the file list below.</div>';
                    }
                }
            } else {
                console.error('ScribeFileTree not available');
            }
            
            // Initialize control buttons and ping mechanism
            initializeControls();
        });
        
        // Control functionality
        function initializeControls() {
            // Ping server every 30 seconds to keep alive
            setInterval(pingServer, 30000);
            
            // Initial ping
            pingServer();
            
            // Setup button event listeners
            const saveBtn = document.getElementById('save-btn');
            const shutdownBtn = document.getElementById('shutdown-btn');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', handleSave);
            }
            
            if (shutdownBtn) {
                shutdownBtn.addEventListener('click', handleShutdown);
            }
        }
        
        async function pingServer() {
            try {
                const response = await fetch('/api/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.warn('Ping failed:', error);
                updateConnectionStatus(false);
            }
        }
        
        function updateConnectionStatus(isOnline) {
            const statusDot = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            if (statusDot && statusText) {
                if (isOnline) {
                    statusDot.className = 'status-dot online';
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.className = 'status-dot offline';
                    statusText.textContent = 'Disconnected';
                }
            }
        }
        
        async function handleSave() {
            const saveBtn = document.getElementById('save-btn');
            if (!saveBtn) return;
            
            // Disable button and show loading
            saveBtn.disabled = true;
            saveBtn.innerHTML = '⏳ Saving...';
            
            try {
                // Get current selected files from the tree
                const selectedFiles = getSelectedFiles();
                
                const response = await fetch('/api/bundle/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: selectedFiles
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    saveBtn.innerHTML = '✅ Saved!';
                    setTimeout(() => {
                        saveBtn.innerHTML = '💾 Save Bundle';
                        saveBtn.disabled = false;
                    }, 2000);
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                saveBtn.innerHTML = '❌ Save Failed';
                setTimeout(() => {
                    saveBtn.innerHTML = '💾 Save Bundle';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }
        
        async function handleShutdown() {
            if (!confirm('Are you sure you want to shutdown the server?')) {
                return;
            }
            
            const shutdownBtn = document.getElementById('shutdown-btn');
            if (!shutdownBtn) return;
            
            // Disable button and show loading
            shutdownBtn.disabled = true;
            shutdownBtn.innerHTML = '⏳ Shutting down...';
            
            try {
                const response = await fetch('/api/shutdown', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    shutdownBtn.innerHTML = '✅ Server stopped';
                    updateConnectionStatus(false);
                    // Show goodbye message
                    setTimeout(() => {
                        document.body.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100vh; font-size: 24px; color: var(--text-primary);">🛑 Server has been shut down</div>';
                    }, 1000);
                } else {
                    throw new Error('Shutdown failed');
                }
            } catch (error) {
                console.error('Shutdown error:', error);
                shutdownBtn.innerHTML = '❌ Shutdown Failed';
                setTimeout(() => {
                    shutdownBtn.innerHTML = '🛑 Shutdown Server';
                    shutdownBtn.disabled = false;
                }, 2000);
            }
        }
        
        function getSelectedFiles() {
            // This would integrate with the React tree component
            // For now, return all files as selected
            return fileData.map(file => file.path);
        }
    </script>
</body>
</html>
