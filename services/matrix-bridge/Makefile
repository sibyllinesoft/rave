# Matrix Bridge Security Testing Framework
# Comprehensive testing with mutation testing â‰¥0.80 and property coverage â‰¥0.70

.PHONY: help install test test-unit test-integration test-security test-mutation test-property test-performance test-contract lint format type-check sast security-scan coverage clean all

# Default target
help: ## Show this help message
	@echo "Matrix Bridge Security Testing Framework"
	@echo "========================================"
	@echo ""
	@echo "Available targets:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-20s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

# Environment setup
PYTHON := python3
PIP := pip3
PYTEST := pytest
COVERAGE := coverage
MUTMUT := mutmut
BANDIT := bandit
SAFETY := safety
BLACK := black
ISORT := isort
FLAKE8 := flake8
MYPY := mypy

# Directories
SRC_DIR := src
TEST_DIR := tests
REPORTS_DIR := reports

# Coverage and mutation testing targets
COVERAGE_TARGET := 95
MUTATION_TARGET := 80
PROPERTY_TARGET := 70

# Test configuration
PYTEST_ARGS := -v --tb=short
PYTEST_COV_ARGS := --cov=$(SRC_DIR) --cov-report=html --cov-report=term --cov-report=xml
PYTEST_TIMEOUT := 300

install: ## Install dependencies
	@echo "Installing dependencies..."
	$(PIP) install -r requirements.txt
	@echo "Dependencies installed successfully"

test: test-unit test-integration test-security ## Run all tests

test-unit: ## Run unit tests with coverage
	@echo "Running unit tests with coverage..."
	@mkdir -p $(REPORTS_DIR)
	$(COVERAGE) run -m $(PYTEST) $(PYTEST_ARGS) $(TEST_DIR)/test_*.py
	$(COVERAGE) report --fail-under=$(COVERAGE_TARGET)
	$(COVERAGE) html -d $(REPORTS_DIR)/coverage_html
	$(COVERAGE) xml -o $(REPORTS_DIR)/coverage.xml
	@echo "Unit tests completed. Coverage report: $(REPORTS_DIR)/coverage_html/index.html"

test-integration: ## Run integration tests
	@echo "Running integration tests..."
	@mkdir -p $(REPORTS_DIR)
	$(PYTEST) $(PYTEST_ARGS) --timeout=$(PYTEST_TIMEOUT) \
		$(TEST_DIR)/test_integration_*.py \
		--junitxml=$(REPORTS_DIR)/integration_results.xml

test-security: ## Run security-focused tests
	@echo "Running security tests..."
	@mkdir -p $(REPORTS_DIR)
	$(PYTEST) $(PYTEST_ARGS) -m "security or slow" \
		$(TEST_DIR)/ \
		--junitxml=$(REPORTS_DIR)/security_results.xml
	@echo "Security tests completed"

test-mutation: ## Run mutation testing (target â‰¥80%)
	@echo "Running mutation testing (target: $(MUTATION_TARGET)%)..."
	@mkdir -p $(REPORTS_DIR)
	@# Initialize mutation testing
	$(MUTMUT) run --paths-to-mutate=$(SRC_DIR)/ \
		--tests-dir=$(TEST_DIR)/ \
		--runner="python -m pytest -x" \
		--use-coverage
	@# Generate mutation test report
	$(MUTMUT) junitxml --suspicious-policy=ignore --untested-policy=ignore > $(REPORTS_DIR)/mutation_results.xml
	$(MUTMUT) show --scores-only > $(REPORTS_DIR)/mutation_scores.txt
	@echo "Mutation testing completed. Results in $(REPORTS_DIR)/"
	@# Check mutation score
	@python3 -c "import re; \
		with open('$(REPORTS_DIR)/mutation_scores.txt') as f: \
			content = f.read(); \
		match = re.search(r'Survived:\s+(\d+\.\d+)%', content); \
		score = float(match.group(1)) if match else 0; \
		target = $(MUTATION_TARGET); \
		print(f'Mutation score: {score}% (target: {target}%)'); \
		exit(0 if score >= target else 1)"

test-property: ## Run property-based tests (target â‰¥70% property coverage)
	@echo "Running property-based tests (target: $(PROPERTY_TARGET)% property coverage)..."
	@mkdir -p $(REPORTS_DIR)
	@# Run hypothesis tests with extensive examples
	$(PYTEST) $(PYTEST_ARGS) --hypothesis-show-statistics \
		--hypothesis-profile=thorough \
		-m "property or hypothesis" \
		$(TEST_DIR)/ \
		--junitxml=$(REPORTS_DIR)/property_results.xml
	@# Generate property coverage report
	@python3 -c "import os, re, glob; \
		test_files = glob.glob('$(TEST_DIR)/test_*.py'); \
		total_functions = 0; \
		property_functions = 0; \
		for file in test_files: \
			with open(file) as f: \
				content = f.read(); \
				total_functions += len(re.findall(r'def test_', content)); \
				property_functions += len(re.findall(r'@given|@rule|@invariant', content)); \
		coverage = (property_functions / max(total_functions, 1)) * 100; \
		target = $(PROPERTY_TARGET); \
		print(f'Property-based test coverage: {coverage:.1f}% (target: {target}%)'); \
		print(f'Property tests: {property_functions}/{total_functions}'); \
		with open('$(REPORTS_DIR)/property_coverage.txt', 'w') as f: \
			f.write(f'Property coverage: {coverage:.1f}%\n'); \
			f.write(f'Property tests: {property_functions}/{total_functions}\n'); \
		exit(0 if coverage >= target else 1)"

test-performance: ## Run performance and load tests
	@echo "Running performance tests..."
	@mkdir -p $(REPORTS_DIR)
	$(PYTEST) $(PYTEST_ARGS) --benchmark-only \
		--benchmark-json=$(REPORTS_DIR)/benchmark_results.json \
		$(TEST_DIR)/

test-contract: ## Run contract tests against Matrix API
	@echo "Running contract tests..."
	@mkdir -p $(REPORTS_DIR)
	$(PYTEST) $(PYTEST_ARGS) -m "contract" \
		$(TEST_DIR)/ \
		--junitxml=$(REPORTS_DIR)/contract_results.xml

test-fuzzing: ## Run fuzzing tests for security
	@echo "Running fuzzing tests..."
	@mkdir -p $(REPORTS_DIR)
	@# Run atheris-based fuzzing (if available)
	@python3 -c "
import sys
try:
    import atheris
    print('Running atheris fuzzing tests...')
    # Run fuzzing tests here
    exec(open('$(TEST_DIR)/fuzz_command_parser.py').read())
except ImportError:
    print('Atheris not available, running basic fuzzing...')
    exec(open('$(TEST_DIR)/test_command_parser.py').read())
" || echo "Fuzzing completed with some failures (expected)"

lint: ## Run all linting tools
	@echo "Running linting tools..."
	$(BLACK) --check $(SRC_DIR)/ $(TEST_DIR)/
	$(ISORT) --check-only $(SRC_DIR)/ $(TEST_DIR)/
	$(FLAKE8) $(SRC_DIR)/ $(TEST_DIR)/

format: ## Format code with black and isort
	@echo "Formatting code..."
	$(BLACK) $(SRC_DIR)/ $(TEST_DIR)/
	$(ISORT) $(SRC_DIR)/ $(TEST_DIR)/

type-check: ## Run mypy type checking
	@echo "Running type checking..."
	$(MYPY) $(SRC_DIR)/ --ignore-missing-imports

sast: ## Run SAST security scanning
	@echo "Running SAST security scanning..."
	@mkdir -p $(REPORTS_DIR)
	@# Bandit for Python security issues
	$(BANDIT) -r $(SRC_DIR)/ -f json -o $(REPORTS_DIR)/bandit_results.json || true
	$(BANDIT) -r $(SRC_DIR)/ -f txt -o $(REPORTS_DIR)/bandit_results.txt || true
	@# Safety for dependency vulnerabilities
	$(SAFETY) check --json --output $(REPORTS_DIR)/safety_results.json || true
	$(SAFETY) check --output $(REPORTS_DIR)/safety_results.txt || true
	@# Semgrep (if available)
	@command -v semgrep >/dev/null 2>&1 && \
		semgrep --config=auto --json --output=$(REPORTS_DIR)/semgrep_results.json $(SRC_DIR)/ || \
		echo "Semgrep not available, skipping advanced SAST"
	@echo "SAST scanning completed. Results in $(REPORTS_DIR)/"

security-scan: sast ## Comprehensive security scanning
	@echo "Running comprehensive security scan..."
	@mkdir -p $(REPORTS_DIR)
	@# Check for high/critical security issues
	@python3 -c "
import json, sys, os
reports_dir = '$(REPORTS_DIR)'

# Check Bandit results
bandit_file = os.path.join(reports_dir, 'bandit_results.json')
if os.path.exists(bandit_file):
    with open(bandit_file) as f:
        bandit_data = json.load(f)
    high_critical = [r for r in bandit_data.get('results', []) 
                     if r.get('issue_severity') in ['HIGH', 'CRITICAL']]
    print(f'Bandit high/critical issues: {len(high_critical)}')
    if high_critical:
        print('HIGH/CRITICAL SECURITY ISSUES FOUND:')
        for issue in high_critical[:5]:  # Show first 5
            print(f'  - {issue.get(\"test_name\")}: {issue.get(\"issue_text\")}')
        sys.exit(1)

# Check Safety results
safety_file = os.path.join(reports_dir, 'safety_results.json')
if os.path.exists(safety_file):
    with open(safety_file) as f:
        content = f.read().strip()
        if content and content != '[]':
            safety_data = json.loads(content)
            if safety_data:
                print(f'Safety vulnerability issues: {len(safety_data)}')
                sys.exit(1)

print('âœ… No high/critical security issues found')
"

coverage: test-unit ## Generate coverage report
	@echo "Coverage report generated in $(REPORTS_DIR)/coverage_html/"
	$(COVERAGE) report

coverage-xml: ## Generate XML coverage report for CI
	@mkdir -p $(REPORTS_DIR)
	$(COVERAGE) xml -o $(REPORTS_DIR)/coverage.xml

clean: ## Clean up generated files
	@echo "Cleaning up..."
	rm -rf $(REPORTS_DIR)/
	rm -rf .coverage
	rm -rf htmlcov/
	rm -rf .pytest_cache/
	rm -rf .mutmut-cache/
	rm -rf .hypothesis/
	rm -rf **/__pycache__/
	rm -rf **/*.pyc
	find . -name "*.pyc" -delete
	find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true

# Comprehensive validation target for CI/CD
validate: ## Run complete validation suite (CI/CD target)
	@echo "Running complete validation suite..."
	@$(MAKE) clean
	@$(MAKE) install
	@$(MAKE) lint
	@$(MAKE) type-check
	@$(MAKE) sast
	@$(MAKE) test-unit
	@$(MAKE) test-security
	@$(MAKE) test-property
	@$(MAKE) test-mutation
	@$(MAKE) security-scan
	@echo ""
	@echo "ðŸŽ‰ Complete validation suite passed!"
	@echo "âœ… Code quality: PASSED"
	@echo "âœ… Security scan: PASSED"
	@echo "âœ… Unit tests: PASSED (coverage â‰¥$(COVERAGE_TARGET)%)"
	@echo "âœ… Security tests: PASSED" 
	@echo "âœ… Property tests: PASSED (coverage â‰¥$(PROPERTY_TARGET)%)"
	@echo "âœ… Mutation tests: PASSED (score â‰¥$(MUTATION_TARGET)%)"
	@$(MAKE) generate-summary

generate-summary: ## Generate test summary report
	@echo "Generating test summary..."
	@mkdir -p $(REPORTS_DIR)
	@python3 -c "
import json, os, xml.etree.ElementTree as ET, glob
from datetime import datetime

reports_dir = '$(REPORTS_DIR)'
summary = {
    'timestamp': datetime.now().isoformat(),
    'validation_status': 'PASSED',
    'metrics': {
        'coverage_target': $(COVERAGE_TARGET),
        'mutation_target': $(MUTATION_TARGET),
        'property_target': $(PROPERTY_TARGET)
    },
    'results': {}
}

# Parse coverage
try:
    with open(os.path.join(reports_dir, 'coverage.xml')) as f:
        root = ET.parse(f).getroot()
        coverage_pct = float(root.get('line-rate', 0)) * 100
        summary['results']['coverage'] = {
            'percentage': coverage_pct,
            'status': 'PASSED' if coverage_pct >= $(COVERAGE_TARGET) else 'FAILED'
        }
except: pass

# Parse mutation results
try:
    with open(os.path.join(reports_dir, 'mutation_scores.txt')) as f:
        content = f.read()
        import re
        match = re.search(r'Survived:\s+(\d+\.\d+)%', content)
        if match:
            mutation_score = float(match.group(1))
            summary['results']['mutation'] = {
                'score': mutation_score,
                'status': 'PASSED' if mutation_score >= $(MUTATION_TARGET) else 'FAILED'
            }
except: pass

# Parse property coverage
try:
    with open(os.path.join(reports_dir, 'property_coverage.txt')) as f:
        content = f.read()
        import re
        match = re.search(r'Property coverage: (\d+\.\d+)%', content)
        if match:
            property_coverage = float(match.group(1))
            summary['results']['property'] = {
                'coverage': property_coverage,
                'status': 'PASSED' if property_coverage >= $(PROPERTY_TARGET) else 'FAILED'
            }
except: pass

# Parse security scan results
security_issues = 0
try:
    with open(os.path.join(reports_dir, 'bandit_results.json')) as f:
        bandit_data = json.load(f)
        security_issues += len([r for r in bandit_data.get('results', []) 
                               if r.get('issue_severity') in ['HIGH', 'CRITICAL']])
except: pass

summary['results']['security'] = {
    'high_critical_issues': security_issues,
    'status': 'PASSED' if security_issues == 0 else 'FAILED'
}

# Write summary
with open(os.path.join(reports_dir, 'validation_summary.json'), 'w') as f:
    json.dump(summary, f, indent=2)

print('ðŸ“Š Validation Summary Generated:')
print(json.dumps(summary, indent=2))
"

# Development helpers
dev-setup: install ## Set up development environment
	@echo "Setting up development environment..."
	@$(PIP) install -e .
	@pre-commit install || echo "pre-commit not available"

watch-tests: ## Run tests in watch mode
	@echo "Running tests in watch mode..."
	@command -v entr >/dev/null 2>&1 && \
		find $(SRC_DIR) $(TEST_DIR) -name "*.py" | entr -c make test-unit || \
		echo "Install 'entr' for watch mode: apt install entr"

# Docker targets
docker-test: ## Run tests in Docker container
	@echo "Running tests in Docker..."
	docker build -t matrix-bridge-test -f Dockerfile.test .
	docker run --rm -v $(PWD)/$(REPORTS_DIR):/app/$(REPORTS_DIR) matrix-bridge-test make validate

# Documentation
docs: ## Generate documentation
	@echo "Generating documentation..."
	@mkdir -p docs/
	@python3 -c "
print('# Matrix Bridge Security Testing')
print('## Test Results')
print('- Coverage: See reports/coverage_html/')
print('- Mutation: See reports/mutation_results.xml')
print('- Security: See reports/bandit_results.txt')
print('- Property: See reports/property_results.xml')
" > docs/testing.md

all: validate docs ## Run everything

# Special target for CI systems
ci: validate generate-summary ## Optimized for CI/CD systems
	@echo "CI validation complete"